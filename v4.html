<!DOCTYPE html>
<html>
<head>
    <title>TreeRadar (v4, Pre)</title>
    <link rel="icon" href="https://raw.githubusercontent.com/microsoft/fluentui-emoji/refs/heads/main/assets/Deciduous%20tree/3D/deciduous_tree_3d.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' rel='stylesheet' />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .context-menu, .alert-popup, .map-popup-base, .sidebar-panel, .glass-button {
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; 
            border-radius: 10px;
            font-family: 'Outfit', sans-serif; 
        }
        
        #alert-popup-container {
            position: fixed;
            bottom: 0; left: 0;
            z-index: 1000; 
            display: flex; 
            flex-direction: column;
            align-items: flex-start;
            pointer-events: none;
            padding-bottom: 10px;
        }

        .alert-popup {
            padding: 15px; 
            margin: 10px 10px 0px 10px;
            width: max-content;
            max-width: 50vw;
            opacity: 0;
            transform: translateX(-120%);
            transition: transform 0.5s ease-out, opacity 0.3s ease-out;
            cursor: pointer; 
            pointer-events: auto;
        }
        .alert-popup.fly-in { opacity: 1; transform: translateX(0); }
        .alert-popup.fly-out { opacity: 0; transform: translateX(-120%); }
        .alert-popup h4 { margin: 0 0 8px 0; font-size: 18px; }
        .alert-popup p { margin: 2px 0; font-size: 14px; white-space: normal; }


        #menu-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 2000;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0;
        }
        #menu-toggle-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        #menu-toggle-btn .material-symbols-rounded {
            font-size: 24px;
            color: white;
        }

        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2001;
            backdrop-filter: blur(2px);
        }

        #sidebar {
            position: fixed;
            top: 0;
            left: -300px;
            width: 280px;
            height: 100%;
            z-index: 2002;
            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex;
            flex-direction: column;
            background: rgba(20, 20, 20, 0.85); 
            border-radius: 0 10px 10px 0;
            border-left: none;
            border-top: none;
            border-bottom: none;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        #sidebar.open {
            left: 0;
        }

        .sidebar-header {
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sidebar-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sidebar-close-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 5px;
            display: flex;
            border-radius: 5px;
        }
        .sidebar-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sidebar-content {
            padding: 10px;
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .sidebar-menu-item {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.9);
            width: 100%;
            padding: 12px 15px;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 400;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 8px;
        }
        .sidebar-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .sidebar-item-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .sidebar-menu-item i {
            font-size: 22px;
        }
        .dropdown-arrow {
            font-size: 20px;
            transition: transform 0.3s ease;
        }
        .sidebar-menu-item.active .dropdown-arrow {
            transform: rotate(180deg);
        }

        .sidebar-dropdown-container {
            display: none;
            flex-direction: column;
            padding-left: 15px;
            gap: 5px;
        }
        .sidebar-dropdown-container.show {
            display: flex;
        }
        
        .sidebar-submenu-item {
            padding: 10px 15px;
            font-size: 15px;
        }


        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            width: max-content;
            overflow: visible;
            padding: 4px;
        }

        .context-submenu { display: none; }
        
        .context-menu ul { list-style: none; padding: 0; margin: 0; min-width: 150px; }
        .context-menu ul li {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            cursor: pointer;
            user-select: none;
            border-radius: 6px;
        }
        .context-menu .material-symbols-rounded { padding-right: 10px; }
        .context-menu ul li .menu-item-text { display: flex; align-items: center; }
        .context-menu ul li:hover { background-color: rgba(255, 255, 255, 0.1); }
        
        .maplibregl-popup-content {
            background: none;
            box-shadow: none;
            padding: 0;
            border-radius: 10px;
        }
        .maplibregl-popup-tip { display: none; }
        .maplibregl-popup-close-button {
            top: 5px;
            right: 5px;
            font-size: 20px;
            z-index: 1;
            color: #ccc;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .maplibregl-popup-close-button:hover {
            color: #fff;
        }

        .map-popup-base { 
            padding: 0; 
            font-size: 14px;
            min-width: 200px;
            overflow: hidden;
            touch-action: pan-y; 
        }

        .map-popup-base h4 {
            margin: 0; 
            padding: 12px 10px;
            font-size: 18px;
            text-align: center;
        }
        .map-popup-base .popup-content-area {
            padding: 4px;
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        
        .map-popup-base .popup-content-area::-webkit-scrollbar {
            width: 4px;
        }
        .map-popup-base .popup-content-area::-webkit-scrollbar-track {
            background: transparent; 
        }
        .map-popup-base .popup-content-area::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3); 
            border-radius: 2px;
        }

        .map-popup-base ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .map-popup-base ul li {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center; 
            padding: 10px;
            cursor: pointer;
            user-select: none;
            border-radius: 6px; 
            font-size: 14px;
        }
        .map-popup-base ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .map-popup-base ul li button {
            background: none;
            border: none;
            color: inherit;
            font: inherit;
            padding: 0;
            margin: 0;
            cursor: pointer;
            width: 100%;
            text-align: center;
            font-size: inherit;
        }
        .map-popup-base ul li button:focus {
            outline: none;
        }
        .map-popup-base .popup-content-area p {
            margin: 8px 10px;
            white-space: normal;
        }
        .map-popup-base .popup-content-area p:first-of-type {
            margin-top: 10px; 
        }
        .map-popup-base .popup-content-area p:last-of-type {
            margin-bottom: 10px; 
        }

        .map-radar-popup-accent { }
        .map-alert-popup-accent-top { }

        .alert-pager {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 30px;
            border-radius: 0 0 10px 10px;
            padding-bottom: 5px;
        }
        .alert-pager .pager-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            margin: 0 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 4px solid transparent; 
            background-clip: padding-box;
            box-sizing: content-box;
        }
        .alert-pager .pager-dot:hover {
            background-color: rgba(255, 255, 255, 0.6);
        }
        .alert-pager .pager-dot.active {
            background-color: rgba(255, 255, 255, 1);
            transform: scale(1.2);
        }

        #full-alert-text-popup-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6); 
            z-index: 2000; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #full-alert-text-popup {
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 10px;
            padding: 15px; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 400px; 
            max-height: 80vh; 
            overflow-y: scroll; 
            -ms-overflow-style: none;  
            scrollbar-width: none;
            position: relative; 
        }

        #full-alert-text-popup::-webkit-scrollbar {
            display: none; 
        }

        #full-alert-text-popup h4 {
            margin: 0 0 10px 0; 
            font-size: 24px;
            text-align: center;
        }

        #full-alert-text-popup p, #full-alert-text-popup pre {
            margin: 5px 0;
            font-size: 16px;
            line-height: 1.4;
        }
        
        #full-alert-text-popup pre {
            white-space: pre-wrap;
            font-family: inherit;
        }
        
        #full-alert-text-popup strong {
            font-weight: bold;
        }
        #attribution-bubble {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            justify-content: center;
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            height: 30px;
            width: 30px;
            border-radius: 15px;
            box-sizing: border-box;
            cursor: pointer;
            overflow: hidden;
        }
        #attribution-bubble:hover {
            background: rgba(40, 40, 40, 0.7);
        }
        #attribution-bubble.expanded {
            width: auto;
            padding: 0 4px;
        }
        #attribution-bubble .material-symbols-rounded {
            font-size: 20px;
            flex-shrink: 0;
        }
        #attribution-bubble .attribution-text {
            display: none;
            margin-right: 8px;
            font-size: 14px;
            white-space: nowrap;
        }
        #attribution-bubble.expanded .attribution-text {
            display: block;
        }
        #attribution-bubble .attribution-text a {
            color: inherit;
            text-decoration: none;
        }
        #attribution-bubble .attribution-text a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="attribution-bubble">
        <i class="material-symbols-rounded">info</i>
        <div class="attribution-text">
            <a href="https://maplibre.org/" target="_blank">MapLibre</a> | <a href="https://carto.com/about-carto/" target="_blank">CARTO</a>, 
            <a href="https://mesonet.agron.iastate.edu/" target="_blank">IEM</a>, 
            <a href="https://noaa.gov/" target="_blank">NOAA/NWS</a>
        </div>
    </div>

    <div id="alert-popup-container"></div>

    <button id="menu-toggle-btn" class="glass-button" title="Menu">
        <i class="material-symbols-rounded">menu</i>
    </button>

    <div id="sidebar-overlay"></div>

    <div id="sidebar" class="sidebar-panel">
        <div class="sidebar-header">
            <h2><i class="material-symbols-rounded">forest</i> TreeRadar</h2>
            <button id="sidebar-close-btn" class="sidebar-close-btn">
                <i class="material-symbols-rounded">close</i>
            </button>
        </div>
        <div class="sidebar-content">
            <div class="sidebar-menu-group">
                <button class="sidebar-menu-item" onclick="toggleSidebarDropdown('outlooks-dropdown', this)">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">map</i>
                        Outlooks
                    </div>
                    <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                </button>
                <div id="outlooks-dropdown" class="sidebar-dropdown-container">
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day1-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_1</i>Day 1</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day1-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="torn"><i class="material-symbols-rounded">tornado</i>Tornado</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="hail"><i class="material-symbols-rounded">weather_hail</i>Hail</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="wind"><i class="material-symbols-rounded">air</i>Wind</button>
                    </div>
                    
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day2-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_2</i>Day 2</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day2-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="torn"><i class="material-symbols-rounded">tornado</i>Tornado</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="hail"><i class="material-symbols-rounded">weather_hail</i>Hail</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="wind"><i class="material-symbols-rounded">air</i>Wind</button>
                    </div>

                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day3-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_3</i>Day 3</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day3-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="3" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="3" data-type="prob"><i class="material-symbols-rounded">percent</i>Probabilistic</button>
                    </div>

                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day48-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">add_circle</i>Day 4-8</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day48-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="4" data-type="prob"><i class="material-symbols-rounded">counter_4</i>Day 4 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="5" data-type="prob"><i class="material-symbols-rounded">counter_5</i>Day 5 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="6" data-type="prob"><i class="material-symbols-rounded">counter_6</i>Day 6 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="7" data-type="prob"><i class="material-symbols-rounded">counter_7</i>Day 7 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="8" data-type="prob"><i class="material-symbols-rounded">counter_8</i>Day 8 Prob.</button>
                    </div>
                    
                    <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="none" data-type="none">
                        <div class="sidebar-item-content">
                            <i class="material-symbols-rounded">cancel</i>None
                        </div>
                    </button>
                </div>
            </div>

            <button id="sidebar-mosaic-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">radar</i>Mosaic</div>
            </button>
            
            <button id="sidebar-alerts-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">warning</i>Alerts</div>
            </button>
            
            <button id="sidebar-sites-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">location_on</i>Sites</div>
            </button>

             <button id="sidebar-debug-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">bug_report</i>Debug File</div>
             </button>
             <input type="file" id="debug-file-input" accept=".json, .geojson" style="display: none;">
        </div>
    </div>


    <div style="display: none;">
        <input type="checkbox" id="radar-toggle" checked>
        <input type="checkbox" id="alerts-toggle" checked>
        <input type="checkbox" id="radar-sites-toggle" checked>
    </div>
    
    <div id="context-menu" class="context-menu">
        <ul>
            <li id="context-menu-outlooks-parent">
                <div class="menu-item-text"><i class="material-symbols-rounded">map</i>Outlooks</div>
                <div class="context-submenu">
                    <ul>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_1</i>Day 1</div>
                            <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="1" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="1" data-type="torn"><div class="menu-item-text"><i class="material-symbols-rounded">tornado</i>Tornado</div></li>
                                    <li class="outlook-type" data-day="1" data-type="hail"><div class="menu-item-text"><i class="material-symbols-rounded">weather_hail</i>Hail</div></li>
                                    <li class="outlook-type" data-day="1" data-type="wind"><div class="menu-item-text"><i class="material-symbols-rounded">air</i>Wind</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_2</i>Day 2</div>
                            <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="2" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="2" data-type="torn"><div class="menu-item-text"><i class="material-symbols-rounded">tornado</i>Tornado</div></li>
                                    <li class="outlook-type" data-day="2" data-type="hail"><div class="menu-item-text"><i class="material-symbols-rounded">weather_hail</i>Hail</div></li>
                                    <li class="outlook-type" data-day="2" data-type="wind"><div class="menu-item-text"><i class="material-symbols-rounded">air</i>Wind</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_3</i>Day 3</div>
                             <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="3" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="3" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">add_circle</i>Day 4-8</div>
                            <div class="context-submenu">
                                <ul>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_4</i>Day 4</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="4" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_5</i>Day 5</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="5" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_6</i>Day 6</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="6" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_7</i>Day 7</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="7" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_8</i>Day 8</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="8" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </li>
                        <li class="outlook-type" data-day="none" data-type="none"><div class="menu-item-text"><i class="material-symbols-rounded">cancel</i>None</div></li>
                    </ul>
                </div>
            </li>
            <li id="context-menu-mosaic"><div class="menu-item-text"><i class="material-symbols-rounded">radar</i>Mosaic</div></li>
            <li id="context-menu-alerts"><div class="menu-item-text"><i class="material-symbols-rounded">warning</i>Alerts</div></li>
            <li id="context-menu-sites"><div class="menu-item-text"><i class="material-symbols-rounded">location_on</i>Sites</div></li>
        </ul>
    </div>

    <script>
        function disableContextMenu(event) {
            event.stopPropagation();
            event.preventDefault();
        }
        
        function toggleSidebarDropdown(id, btnElement) {
            const dropdown = document.getElementById(id);
            if (dropdown) {
                dropdown.classList.toggle('show');
                btnElement.classList.toggle('active');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('context-menu').addEventListener('contextmenu', disableContextMenu);
            document.getElementById('attribution-bubble').addEventListener('contextmenu', disableContextMenu);
            document.getElementById('alert-popup-container').addEventListener('contextmenu', disableContextMenu);
            
            const sidebar = document.getElementById('sidebar');
            const sidebarOverlay = document.getElementById('sidebar-overlay');
            const menuBtn = document.getElementById('menu-toggle-btn');
            const closeBtn = document.getElementById('sidebar-close-btn');
            
            const sbMosaicBtn = document.getElementById('sidebar-mosaic-btn');
            const sbAlertsBtn = document.getElementById('sidebar-alerts-btn');
            const sbSitesBtn = document.getElementById('sidebar-sites-btn');
            
            const sbDebugBtn = document.getElementById('sidebar-debug-btn');
            const debugInput = document.getElementById('debug-file-input');

            sidebar.addEventListener('contextmenu', disableContextMenu);
            menuBtn.addEventListener('contextmenu', disableContextMenu);

            function openSidebar() {
                sidebar.classList.add('open');
                sidebarOverlay.style.display = 'block';
            }

            function closeSidebar() {
                sidebar.classList.remove('open');
                sidebarOverlay.style.display = 'none';
            }

            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openSidebar();
            });

            closeBtn.addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);
            
            sbMosaicBtn.addEventListener('click', () => {
                const radarToggle = document.getElementById('radar-toggle');
                radarToggle.checked = !radarToggle.checked;
                updateMosaicVisibility();
            });
            
            sbAlertsBtn.addEventListener('click', () => {
                const alertsToggle = document.getElementById('alerts-toggle');
                const newState = !alertsToggle.checked;
                alertsToggle.checked = newState;
                const v = newState ? 'visible' : 'none';
                const alertLayers = [layerIds.alertsZone, layerIds.alertsZoneBorder, layerIds.alertsPolygon, layerIds.alertsPolygonBorder];
                alertLayers.forEach(layerId => {
                    if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', v);
                });
            });
            
            sbSitesBtn.addEventListener('click', () => {
                const sitesToggle = document.getElementById('radar-sites-toggle');
                sitesToggle.checked = !sitesToggle.checked;
                if (map.getLayer(layerIds.radarSites)) map.setLayoutProperty(layerIds.radarSites, 'visibility', sitesToggle.checked ? 'visible' : 'none');
            });
            
            const sidebarOutlookBtns = document.querySelectorAll('.sidebar-menu-item.outlook-type');
            sidebarOutlookBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    activeSpcDay = btn.dataset.day;
                    activeSpcType = btn.dataset.type;
                    updateSpcLayerVisibility();
                    closeSidebar();
                });
            });
            
            sbDebugBtn.addEventListener('click', () => {
                debugInput.click();
                closeSidebar();
            });
            
            debugInput.addEventListener('change', handleDebugUpload);

            const fullAlertOverlay = document.createElement('div');
            fullAlertOverlay.id = 'full-alert-text-popup-overlay';
            fullAlertOverlay.innerHTML = `
                <div id="full-alert-text-popup">
                    <button class="maplibregl-popup-close-button" type="button" aria-label="Close popup" aria-hidden="true">Ã—</button>
                    <div id="full-alert-text-content"></div>
                </div>
            `;
            document.body.appendChild(fullAlertOverlay);
            fullAlertOverlay.addEventListener('contextmenu', disableContextMenu);
            fullAlertOverlay.style.display = 'none'; 

            document.querySelector('#full-alert-text-popup .maplibregl-popup-close-button').addEventListener('click', () => {
                document.getElementById('full-alert-text-popup-overlay').style.display = 'none';
            });

            const attributionBubble = document.getElementById('attribution-bubble');
            attributionBubble.addEventListener('click', (event) => {
                event.stopPropagation();
                attributionBubble.classList.toggle('expanded');
            });
        });

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            center: [-97, 39],
            zoom: 2.75,
            attributionControl: false
        });

        const layerIds = {
            radar: 'weather-radar-layer',
            alertsZone: 'alerts-zone-layer',
            alertsZoneBorder: 'alerts-zone-border-layer',
            alertsPolygon: 'alerts-polygon-layer',
            alertsPolygonBorder: 'alerts-polygon-border-layer',
            radarSites: 'nws-radar-sites-layer',
            singleSiteRadar: 'single-site-radar-layer',
            spc: {
                day1: { cat: 'spc-day1-cat', torn: 'spc-day1-torn', hail: 'spc-day1-hail', wind: 'spc-day1-wind' },
                day2: { cat: 'spc-day2-cat', torn: 'spc-day2-torn', hail: 'spc-day2-hail', wind: 'spc-day2-wind' },
                day3: { cat: 'spc-day3-cat', prob: 'spc-day3-prob' },
                day4: { prob: 'spc-day4-prob' },
                day5: { prob: 'spc-day5-prob' },
                day6: { prob: 'spc-day6-prob' },
                day7: { prob: 'spc-day7-prob' },
                day8: { prob: 'spc-day8-prob' }
            }
        };
        
        let activeSpcDay = 'none';
        let activeSpcType = 'none';
        let countyDataMap = new Map();
        let ugcGeoCache = new Map();

        let activeSiteIdForMenu = null, activeSiteIdForData = null, activeRadarProductCode = null;
        let currentMapPopup = null; 
        let allRadarSitesData = []; 

        let currentStackedAlertsOnMap = []; 
        let currentStackedAlertIndex = 0;
        
        let globalPolyAlerts = [];
        let globalZoneAlerts = [];
        
        let alertQueue = [], seenAlerts = new Set(), isDisplayingAlert = false, isInitialLoad = true;
        let activeAlertFlashes = new Map();
        
        let updateIntervalId = null;

        const baseSpcLayerIds = Object.values(layerIds.spc).flatMap(day => Object.values(day));
        const allSpcLayerIds = baseSpcLayerIds.flatMap(id => [id, `${id}-border`]);

        const spcSources = [
            { id: layerIds.spc.day1.cat, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day1.torn, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day1.hail, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day1.wind, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day2.cat, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day2.torn, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day2.hail, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day2.wind, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day3.cat, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day3.prob, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_prob.nolyr.geojson' },
            { id: layerIds.spc.day4.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day4prob.nolyr.geojson' },
            { id: layerIds.spc.day5.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day5prob.nolyr.geojson' },
            { id: layerIds.spc.day6.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day6prob.nolyr.geojson' },
            { id: layerIds.spc.day7.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day7prob.nolyr.geojson' },
            { id: layerIds.spc.day8.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day8prob.nolyr.geojson' }
        ];

        const alertColorMap = {
            'Tornado Warning': '#FF0000',
            'Tornado Watch': '#FFFF00',
            'Severe Thunderstorm Warning': '#FFA500',
            'Severe Thunderstorm Watch': '#DB7093',
            'Flash Flood Warning': '#8B0000',
            'Flash Flood Statement': '#8B0000',
            'Flash Flood Watch': '#2E8B57',
            'Flood Warning': '#00FF00',
            'Flood Statement': '#00FF00',
            'Flood Watch': '#2E8B57',
            'Flood Advisory': '#00FF7F',
            'Special Marine Warning': '#FFA500',
            'Marine Weather Statement': '#FFDAB9',
            'Special Weather Statement': '#FFE4B5',
            'Storm Warning': '#9400D3',
            'Storm Watch': '#FFE4B5',
            'Winter Storm Warning': '#FF69B4',
            'Winter Storm Watch': '#4682B4',
            'Winter Weather Advisory': '#7B68EE',
            'Blizzard Warning': '#FF4500',
            'Blizzard Watch': '#ADFF2F',
            'Ice Storm Warning': '#8B008B',
            'Snow Squall Warning': '#C71585',
            'High Wind Warning': '#DAA520',
            'High Wind Watch': '#B8860B',
            'Wind Advisory': '#D2B48C',
            'Gale Warning': '#DDA0DD',
            'Gale Watch': '#FFC0CB',
            'Hurricane Warning': '#DC143C',
            'Hurricane Watch': '#FF00FF',
            'Tropical Storm Warning': '#B22222',
            'Tropical Storm Watch': '#F08080',
            'Red Flag Warning': '#FF1493',
            'Fire Weather Watch': '#FFDEAD',
            'Heat Advisory': '#FF7F50',
            'Excessive Heat Warning': '#C71585',
            'Excessive Heat Watch': '#800000',
            'Freeze Warning': '#483D8B',
            'Freeze Watch': '#00FFFF',
            'Frost Advisory': '#6495ED',
            'Dense Fog Advisory': '#708090',
            'Air Quality Alert': '#808080',
            'Dust Storm Warning': '#FF8C00',
            'Blowing Dust Warning': '#FF8C00',
            'Blowing Dust Advisory': '#BDB76B',
            'Small Craft Advisory': '#D8BFD8',
            'Hazardous Seas Warning': '#D8BFD8',
            'Hazardous Seas Watch': '#483D8B',
            'Lake Wind Advisory': '#D2B48C',
            'Beach Hazards Statement': '#40E0D0',
            'Coastal Flood Warning': '#228B22',
            'Coastal Flood Watch': '#66CDAA',
            'Coastal Flood Advisory': '#7CFC00',
            'Tsunami Warning': '#FD6347',
            'Tsunami Watch': '#FF00FF',
            'Tsunami Advisory': '#D2691E',
            'Civil Emergency Message': '#FFB6C1',
            'Law Enforcement Warning': '#C0C0C0',
            'Shelter In Place Warning': '#FA8072',
            'Evacuation - Immediate': '#7FFF00',
            '911 Telephone Outage': '#C0C0C0',
            'Administrative Message': '#FFFFFF',
            'Child Abduction Emergency': '#FFFFFF',
            'Extreme Wind Warning': '#FF8C00',
            'Test': '#F0F8FF'
        };

        function hexToRgba(hex, alpha) {
            if (!hex) return `rgba(128, 128, 128, ${alpha})`;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function parseApiDate(dateString) {
            return new Date(dateString);
        }
        
        function getSpecificAlertName(props) {
            const event = props.event;
            const params = props.parameters || {};

            if (event === 'Tornado Warning') {
                const threat = params.tornadoDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Tornado';
                if (threat === 'CONSIDERABLE') return 'Considerable Tornado';
                if (params.tornadoDetection?.[0] === 'OBSERVED') return 'Confirmed Tornado';
            }
            if (event === 'Severe Thunderstorm Warning') {
                const threat = params.thunderstormDamageThreat?.[0];
                if (threat === 'DESTRUCTIVE') return 'Destructive Thunderstorm';
                if (threat === 'CONSIDERABLE') return 'Considerable Thunderstorm';
                if (params.tornadoDetection?.[0] === 'POSSIBLE') return 'Tornado Possible';
            }
            if (event === 'Special Marine Warning' || event === 'Marine Weather Statement') {
                 const threat = params.waterspoutDetection?.[0];
                 if (threat === 'OBSERVED') return 'Confirmed Waterspout';
                 if (threat === 'POSSIBLE') return 'Waterspout Possible';
            }
            if (event === 'Flash Flood Warning') {
                const threat = params.flashFloodDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Flash Flood';
                if (threat === 'CONSIDERABLE') return 'Considerable Flash Flood';
            }

            return event;
        }
        
        function isValidAlert(feature) {
            const props = feature.properties;
            if (!props) return false;
            
            if (props.parameters && props.parameters.VTEC && props.parameters.VTEC[0] && props.parameters.VTEC[0].startsWith("/O.CAN.")) {
                return false;
            }
            
            return true;
        }

        function formatThreatValue(value) {
            if (!value || typeof value !== 'string') return '';
            const cleanedValue = value.toUpperCase() === 'N/A' ? '' : value;
            if (!cleanedValue) return '';
            return cleanedValue.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }
        
        function flashAlertOnMap(feature, duration = 10000) {
            if (!feature || !feature.geometry || !feature.properties || !feature.properties.id) return;

            const alertId = feature.properties.id;
            const now = Date.now();
            const existingFlash = activeAlertFlashes.get(alertId);

            if (existingFlash) {
                const remainingTime = existingFlash.endTime - now;
                if (remainingTime > 3000) {
                    return;
                } else {
                    clearTimeout(existingFlash.timeoutId);
                    if (map.getLayer(existingFlash.borderHighlightId)) map.removeLayer(existingFlash.borderHighlightId);
                    if (map.getLayer(existingFlash.highlightId)) map.removeLayer(existingFlash.highlightId);
                    if (map.getSource(existingFlash.highlightId)) map.removeSource(existingFlash.highlightId);
                    activeAlertFlashes.delete(alertId);
                }
            }

            const highlightId = 'highlight-' + alertId + '-' + now;
            const borderHighlightId = highlightId + '-border';

            map.addSource(highlightId, { 'type': 'geojson', 'data': feature });
            map.addLayer({
                'id': highlightId, 'type': 'fill', 'source': highlightId,
                'paint': {
                    'fill-color': '#ffffff', 'fill-opacity': 0,
                    'fill-opacity-transition': { duration: 450 }
                }
            });
            map.addLayer({
                'id': borderHighlightId, 'type': 'line', 'source': highlightId,
                'paint': {
                    'line-color': '#ffffff', 'line-width': 2, 'line-opacity': 0,
                    'line-opacity-transition': { duration: 450 }
                }
            });

            const setOpacity = (fillOpacity, lineOpacity) => {
                if (map.getLayer(highlightId)) map.setPaintProperty(highlightId, 'fill-opacity', fillOpacity);
                if (map.getLayer(borderHighlightId)) map.setPaintProperty(borderHighlightId, 'line-opacity', lineOpacity);
            };

            const flashCount = Math.floor(duration / 2000);
            for (let i = 0; i < flashCount; i++) {
                setTimeout(() => setOpacity(0.25, 0.9), i * 2000);
                setTimeout(() => setOpacity(0, 0), i * 2000 + 1000);
            }

            const cleanupDelay = duration + 500;

            const timeoutId = setTimeout(() => {
                if (map.getLayer(borderHighlightId)) map.removeLayer(borderHighlightId);
                if (map.getLayer(highlightId)) map.removeLayer(highlightId);
                if (map.getSource(highlightId)) map.removeSource(highlightId);
                activeAlertFlashes.delete(alertId);
            }, cleanupDelay);

            activeAlertFlashes.set(alertId, {
                timeoutId: timeoutId,
                endTime: now + cleanupDelay,
                highlightId: highlightId,
                borderHighlightId: borderHighlightId
            });
        }

        function flyToAlert(feature) {
            if (!feature || !feature.geometry || !feature.geometry.coordinates) return;
            const bounds = new maplibregl.LngLatBounds();
            try {
                const processCoords = (coords) => {
                    for(const coord of coords) {
                        if (Array.isArray(coord[0])) { processCoords(coord); }
                        else { bounds.extend(coord); }
                    }
                };
                processCoords(feature.geometry.coordinates);
                if (bounds.getNorthEast() && bounds.getSouthWest()) {
                    map.fitBounds(bounds, { padding: 150, essential: true });
                    map.once('moveend', () => flashAlertOnMap(feature, 6000));
                }
            } catch(e) { console.error("FlyTo Error:", e); }
        }

        function createAndShowAlertPopup(feature, source) {
            const props = feature.properties;
            const params = props.parameters || {};
            const container = document.getElementById('alert-popup-container');
            const popup = document.createElement('div');
            popup.className = 'alert-popup';

            popup.addEventListener('contextmenu', disableContextMenu);

            const specificAlertName = props.specificEventName;
            const accentColor = alertColorMap[props.event] || '#808080';
            
            let title = (source === 'new' && props.messageType === 'Update' ? 'Updated - ' : '') + specificAlertName;

            let detailsHTML = '<div>';
            
            const expireDate = parseApiDate(props.expires);
            if (expireDate && !isNaN(expireDate.getTime())) {
                const dateOptions = { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
                const expireString = expireDate.toLocaleString('en-US', dateOptions);
                detailsHTML += `<p><strong>Expires:</strong> ${expireString}</p>`;
            }

            if (props.areaDesc && props.areaDesc.toUpperCase() !== 'N/A') {
                detailsHTML += `<p><strong>Affected:</strong> ${props.areaDesc}</p>`;
            }

            const tornado = params.tornadoDetection ? params.tornadoDetection[0] : null;
            if (tornado && formatThreatValue(tornado)) { 
                detailsHTML += `<p><strong>Tornado:</strong> ${formatThreatValue(tornado)}</p>`;
            }

            const waterspout = params.waterspoutDetection ? params.waterspoutDetection[0] : null;
            if (waterspout && formatThreatValue(waterspout)) {
                detailsHTML += `<p><strong>Waterspout:</strong> ${formatThreatValue(waterspout)}</p>`;
            }

            const damageThreat = params.tornadoDamageThreat?.[0] || params.thunderstormDamageThreat?.[0] || params.flashFloodDamageThreat?.[0];
            if (damageThreat && formatThreatValue(damageThreat)) {
                detailsHTML += `<p><strong>Threat:</strong> ${formatThreatValue(damageThreat)}</p>`;
            }

            const windGust = params.maxWindGust ? params.maxWindGust[0] : null;
            if (windGust && windGust !== '0 MPH' && formatThreatValue(windGust)) {
                const windThreat = params.windThreat ? params.windThreat[0] : null;
                let windText = windGust.replace("MPH", "mph");
                if (windThreat && formatThreatValue(windThreat)) {
                    windText += `, ${formatThreatValue(windThreat)}`;
                }
                detailsHTML += `<p><strong>Winds:</strong> ${windText}</p>`;
            }

            const hailSize = params.maxHailSize ? params.maxHailSize[0] : null;
            if (hailSize && hailSize !== '0.00' && formatThreatValue(hailSize)) {
                const hailThreat = params.hailThreat ? params.hailThreat[0] : null;
                let hailText = hailSize + '"';
                if (hailThreat && formatThreatValue(hailThreat)) {
                    hailText += `, ${formatThreatValue(hailThreat)}`;
                }
                detailsHTML += `<p><strong>Hail:</strong> ${hailText}</p>`;
            }

            const flashFloodDetection = params.flashFloodDetection ? params.flashFloodDetection[0] : null;
            if (flashFloodDetection && formatThreatValue(flashFloodDetection)) {
                detailsHTML += `<p><strong>Source:</strong> ${formatThreatValue(flashFloodDetection)}</p>`;
            }

            detailsHTML += '</div>';
            
            const popupHTML = `<h4>${title}</h4>${detailsHTML}`;

            popup.style.borderLeft = `5px solid ${hexToRgba(accentColor, 0.5)}`;
            popup.innerHTML = popupHTML;
            popup.addEventListener('click', () => flyToAlert(feature));

            container.appendChild(popup);
            setTimeout(() => popup.classList.add('fly-in'), 10);
            
            setTimeout(() => {
                popup.classList.remove('fly-in');
                popup.classList.add('fly-out');
            }, 7000);

            setTimeout(() => {
                popup.remove();
                if (source === 'new') {
                    setTimeout(() => { isDisplayingAlert = false; displayNextAlert(); }, 1000);
                }
            }, 7500);
        }

        function displayNextAlert() {
            if (isDisplayingAlert || alertQueue.length === 0) return;
            isDisplayingAlert = true;
            const { feature } = alertQueue.shift();
            flashAlertOnMap(feature, 10000);
            createAndShowAlertPopup(feature, 'new');
        }
        
        function addNewAlertsToQueue(features, type) {
            if (!features) return;
            features.forEach(feature => {
                const props = feature.properties;
                const id = props.id;
                
                if (!seenAlerts.has(id)) {
                    seenAlerts.add(id);
                    if (!isInitialLoad) { 
                        alertQueue.push({ feature, type });
                    }
                }
            });
            
            if (!isInitialLoad) {
                displayNextAlert();
            }
        }
        
        async function processRawAlertFeatures(rawFeatures) {
            const validFeatures = rawFeatures.filter(isValidAlert);
            
            const polyFeatures = [];
            const zoneFeatures = [];

            validFeatures.forEach(feature => {
                feature.properties.specificEventName = getSpecificAlertName(feature.properties);

                if (feature.geometry) {
                    feature.properties.geometryType = 'polygon';
                    polyFeatures.push(feature);
                } else {
                    zoneFeatures.push(feature);
                }
            });

            if (map.getSource('alerts-poly')) {
                map.getSource('alerts-poly').setData({ type: 'FeatureCollection', features: polyFeatures });
            }
            globalPolyAlerts = polyFeatures;
            
            addNewAlertsToQueue(polyFeatures, 'alert');

            await processZoneAlerts(zoneFeatures);
        }
        
        function handleDebugUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.features) throw new Error("Invalid GeoJSON: No features found.");

                    if (updateIntervalId) clearInterval(updateIntervalId);
                    console.log("Live updates paused for debug mode.");
                    
                    isInitialLoad = false;

                    data.features.forEach(feature => {
                        if (!feature.properties.id) feature.properties.id = "debug_" + Math.random().toString(36).substr(2, 9);
                    });
                    
                    await processRawAlertFeatures(data.features);
                    
                    const firstPoly = data.features.find(f => f.geometry);
                    if (firstPoly) flyToAlert(firstPoly);

                } catch (err) {
                    console.error("Error parsing debug file:", err);
                    alert("Error parsing GeoJSON file.");
                }
            };
            reader.readAsText(file);
        }

        function updateMosaicVisibility() {
            const mosaicToggle = document.getElementById('radar-toggle');
            const isMosaicEnabledByUser = mosaicToggle.checked;
            const isSiteRadarActive = map.getLayer(layerIds.singleSiteRadar);

            if (map.getLayer(layerIds.radar)) {
                if (isSiteRadarActive) {
                    map.setLayoutProperty(layerIds.radar, 'visibility', 'none');
                } else {
                    map.setLayoutProperty(layerIds.radar, 'visibility', isMosaicEnabledByUser ? 'visible' : 'none');
                }
            }
        }

        function removeSingleSiteLayer() {
            if (map.getLayer(layerIds.singleSiteRadar)) map.removeLayer(layerIds.singleSiteRadar);
            if (map.getSource('single-site-radar-source')) map.removeSource('single-site-radar-source');
        }

        function closeAllPopups() {
            const maplibrePopups = document.querySelectorAll('.maplibregl-popup');
            maplibrePopups.forEach(popup => popup.remove());

            activeSiteIdForMenu = null;
            currentMapPopup = null; 
            currentStackedAlertsOnMap = [];
            currentStackedAlertIndex = 0;
            document.getElementById('full-alert-text-popup-overlay').style.display = 'none';
        }
        
        function toggleRadarProduct(stationId, productCode) {
            const isTogglingOff = activeSiteIdForData === stationId && activeRadarProductCode === productCode;
            removeSingleSiteLayer();
            if (isTogglingOff) {
                activeRadarProductCode = null;
                activeSiteIdForData = null;
            } else {
                activeRadarProductCode = productCode;
                activeSiteIdForData = stationId;
                const tileUrl = `https://opengeo.ncep.noaa.gov/geoserver/${stationId}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${stationId}_${productCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`;
                map.addSource('single-site-radar-source', { 'type': 'raster', 'tiles': [tileUrl], 'tileSize': 256, 'attribution': 'Radar data from NOAA' });
                map.addLayer({ 'id': layerIds.singleSiteRadar, 'type': 'raster', 'source': 'single-site-radar-source', 'paint': {} }, layerIds.alertsZone); 
            }
            updateMosaicVisibility();
        }

        async function updateAlerts() {
            try {
                const response = await fetch('https://api.weather.gov/alerts/active?status=actual&message_type=alert,update');
                if (!response.ok) throw new Error(`NWS API fetch error: ${response.statusText}`);
                const data = await response.json();

                await processRawAlertFeatures(data.features);
                
                if (isInitialLoad) {
                    isInitialLoad = false;
                    console.log("Initial alert data loaded. Now tracking new alerts.");
                }

            } catch (e) {
                console.error("Alerts Fetch ERR:", e);
            }
        }

        async function processZoneAlerts(featuresToProcess) {
            const promises = featuresToProcess.map(async (feature) => {
                const props = feature.properties;
                
                let alertGeometries = [];
                if (props.geocode && props.geocode.UGC && props.geocode.UGC.length > 0) {
                    for (const ugcCode of props.geocode.UGC) {
                        if (ugcGeoCache.has(ugcCode)) {
                            const cachedGeo = ugcGeoCache.get(ugcCode);
                            if (cachedGeo) {
                                    if (cachedGeo.type === 'Polygon') alertGeometries.push(cachedGeo.coordinates);
                                    else if (cachedGeo.type === 'MultiPolygon') alertGeometries.push(...cachedGeo.coordinates);
                            }
                            continue;
                        }

                        const type = ugcCode.charAt(2).toUpperCase() === 'C' ? 'county' : 'forecast';
                        const url = `https://api.weather.gov/zones/${type}/${ugcCode}`;

                        try {
                            const zoneResponse = await fetch(url);
                            if (!zoneResponse.ok) throw new Error(`Failed to fetch UGC zone for ${ugcCode}`);
                            const zoneData = await zoneResponse.json();
                            
                            if (zoneData.geometry) {
                                ugcGeoCache.set(ugcCode, zoneData.geometry);
                                if (zoneData.geometry.type === 'Polygon') alertGeometries.push(zoneData.geometry.coordinates);
                                else if (zoneData.geometry.type === 'MultiPolygon') alertGeometries.push(...zoneData.geometry.coordinates);
                            } else {
                                ugcGeoCache.set(ugcCode, null);
                            }
                        } catch (error) {
                            console.error(error);
                            ugcGeoCache.set(ugcCode, null);
                        }
                    }
                }

                if (alertGeometries.length === 0 && props.geocode && props.geocode.SAME) {
                    props.geocode.SAME.forEach(fipsCode => {
                        const countyFIPS = fipsCode.substring(1);
                        const countyFeature = countyDataMap.get(countyFIPS);
                        if (countyFeature && countyFeature.geometry) {
                            if (countyFeature.geometry.type === 'Polygon') alertGeometries.push(countyFeature.geometry.coordinates);
                            else if (countyFeature.geometry.type === 'MultiPolygon') alertGeometries.push(...countyFeature.geometry.coordinates);
                        }
                    });
                }

                if (alertGeometries.length > 0) {
                    return {
                        type: 'Feature',
                        geometry: { type: 'MultiPolygon', coordinates: alertGeometries },
                        properties: { ...props, geometryType: 'zone' }
                    };
                }
                
                return null;
            });

            const resolvedFeatures = (await Promise.all(promises)).filter(Boolean);

            if (map.getSource('alerts-zone')) {
                map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: resolvedFeatures });
            }
            globalZoneAlerts = resolvedFeatures;
            
            addNewAlertsToQueue(resolvedFeatures, 'alert');
        }

        async function checkRadarStatus() {
            console.log("Checking radar statuses...");
            const now = Date.now();
            const twentyMinutesAgo = now - (20 * 60 * 1000); 
            let changedStatus = false;
            
            const updatedRadarSitesData = [...allRadarSitesData];

            for (let i = 0; i < updatedRadarSitesData.length; i++) {
                const site = updatedRadarSitesData[i];
                const radarId = site.properties.id;
                let isOffline = site.properties.isOffline; 

                try {
                    const response = await fetch(`https://api.weather.gov/radar/stations/${radarId}`);
                    if (!response.ok) throw new Error(`Failed to fetch status for ${radarId}`);
                    const data = await response.json();
                    
                    const levelTwoTimeStr = data.properties.latency?.levelTwoLastReceivedTime;
                    let newIsOffline = false;

                    if (levelTwoTimeStr) {
                        const levelTwoTime = new Date(levelTwoTimeStr).getTime();
                        if (levelTwoTime < twentyMinutesAgo) {
                            newIsOffline = true;
                        }
                    } else {
                        newIsOffline = true;
                    }

                    if (isOffline !== newIsOffline) {
                        updatedRadarSitesData[i] = {
                            ...site,
                            properties: {
                                ...site.properties,
                                isOffline: newIsOffline
                            }
                        };
                        changedStatus = true;
                    }

                } catch (error) {
                    console.error(`Error checking status for radar ${radarId}:`, error);
                    if (!isOffline) {
                        updatedRadarSitesData[i] = {
                            ...site,
                            properties: {
                                ...site.properties,
                                isOffline: true
                            }
                        };
                        changedStatus = true;
                    }
                }
            }

            allRadarSitesData = updatedRadarSitesData; 
            
            if (changedStatus && map.getSource('radar-sites')) {
                map.getSource('radar-sites').setData({
                    type: 'FeatureCollection',
                    features: allRadarSitesData
                });
                console.log("Radar statuses updated on map.");
            } else if (!changedStatus) {
                console.log("No radar status changes detected.");
            }
        }

        async function fetchSpcOutlookText(day) {
            let url;
            if (parseInt(day) >= 4) {
                url = 'https://www.spc.noaa.gov/products/exper/day4-8/index.html';
            } else {
                url = `https://www.spc.noaa.gov/products/outlook/day${day}otlk.html`;
            }

            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

            try {
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.contents) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(data.contents, 'text/html');
                    const preTag = doc.querySelector('pre');
                    
                    if (preTag) {
                        return preTag.textContent;
                    } else {
                        return "Could not find forecast text in SPC page.";
                    }
                } else {
                    throw new Error('No content in proxy response');
                }
            } catch (error) {
                console.error('Error fetching SPC text:', error);
                return "Failed to load SPC forecast discussion.";
            }
        }


        function updateRadar() { if (map.getSource('weather-radar')) map.getSource('weather-radar').setTiles([ `https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?service=WMS&version=1.1.1&request=GetMap&layers=nexrad-n0q-900913&srs=EPSG:900913&width=256&height=256&format=image/png&transparent=true&bbox={bbox-epsg-3857}&_=${new Date().getTime()}` ]); }
        function updateSingleSiteRadar() { if (map.getSource('single-site-radar-source') && activeSiteIdForData && activeRadarProductCode) { const source = map.getSource('single-site-radar-source'); const tileUrl = `https://opengeo.ncep.noaa.gov/geoserver/${activeSiteIdForData}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${activeSiteIdForData}_${activeRadarProductCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`; source.setTiles([tileUrl]); } }
        async function updateSpcOutlooks() { for (const sourceInfo of spcSources) { const source = map.getSource(sourceInfo.id); if (source) { try { const response = await fetch(`${sourceInfo.url}?t=${new Date().getTime()}`); if (!response.ok) throw new Error(`SPC fetch error for ${sourceInfo.id}`); const geojsonData = await response.json(); source.setData(geojsonData); } catch (error) { console.error(`Failed to refresh SPC outlook for ${sourceInfo.id}:`, error); } } } }

        async function setupMapData() {
            if (countyDataMap.size === 0) {
                try {
                    const response = await fetch('https://raw.githubusercontent.com/12treesarecool34/treewarn/main/counties-simplified.json');
                    const allCountiesGeoJSON = await response.json();
                    allCountiesGeoJSON.features.forEach(county => {
                        countyDataMap.set(county.properties.FIPS, county);
                    });
                    console.log("County geometry data loaded successfully.");
                } catch (error) {
                    console.error("Fatal Error: Could not load county geometry data.", error);
                    return; 
                }
            }
            
            let firstSymbolId;
            for (const layer of map.getStyle().layers) { if (layer.type === 'symbol') { firstSymbolId = layer.id; break; } }
            
            spcSources.forEach(source => {
                if (!map.getSource(source.id)) {
                    map.addSource(source.id, { type: 'geojson', data: source.url });
                }
            });

            if (!map.getSource('weather-radar')) {
                map.addSource('weather-radar', { 'type': 'raster', 'tiles': [`https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?service=WMS&version=1.1.1&request=GetMap&layers=nexrad-n0q-900913&srs=EPSG:900913&width=256&height=256&format=image/png&transparent=true&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`], 'tileSize': 256 });
            }

            if (!map.getSource('alerts-poly')) {
                map.addSource('alerts-poly', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            }
            if (!map.getSource('alerts-zone')) {
                map.addSource('alerts-zone', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            }
            
            if (allRadarSitesData.length === 0) {
                 const radarSitesResponse = await fetch('https://api.weather.gov/radar/stations?stationType=WSR-88D,TDWR');
                 const radarSitesData = await radarSitesResponse.json();
                 allRadarSitesData = radarSitesData.features.map(feature => ({
                    ...feature,
                    properties: {
                        ...feature.properties,
                        isOffline: false 
                    }
                }));
            }

            if (!map.getSource('radar-sites')) {
                map.addSource('radar-sites', { type: 'geojson', data: { type: 'FeatureCollection', features: allRadarSitesData } });
            }

            const alertColorExpression = ['match', ['get', 'event']]; 
            for (const name in alertColorMap) {
                alertColorExpression.push(name, alertColorMap[name]);
            }
            alertColorExpression.push('#808080'); 

            if (!map.getLayer(layerIds.alertsZone)) {
                map.addLayer({ id: layerIds.alertsZone, type: 'fill', source: 'alerts-zone', paint: { 'fill-color': alertColorExpression, 'fill-opacity': 0.1 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'zone'] }, firstSymbolId);
            }
            if (!map.getLayer(layerIds.alertsZoneBorder)) {
                map.addLayer({ id: layerIds.alertsZoneBorder, type: 'line', source: 'alerts-zone', paint: { 'line-color': alertColorExpression, 'line-width': 1 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'zone'] }, firstSymbolId);
            }
            
            if (!map.getLayer(layerIds.alertsPolygon)) {
                map.addLayer({ id: layerIds.alertsPolygon, type: 'fill', source: 'alerts-poly', paint: { 'fill-color': alertColorExpression, 'fill-opacity': 0.3 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'polygon'] }, firstSymbolId);
            }
            if (!map.getLayer(layerIds.alertsPolygonBorder)) {
                map.addLayer({ id: layerIds.alertsPolygonBorder, type: 'line', source: 'alerts-poly', paint: { 'line-color': alertColorExpression, 'line-width': 2 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'polygon'] }, firstSymbolId);
            }
            
            if (!map.getLayer(layerIds.radar)) {
                map.addLayer({ id: layerIds.radar, type: 'raster', source: 'weather-radar', layout: { 'visibility': document.getElementById('radar-toggle').checked ? 'visible' : 'none' } }, layerIds.alertsZone); 
            }

            spcSources.forEach(source => {
                if (!map.getLayer(source.id)) {
                    map.addLayer({ id: source.id, type: 'fill', source: source.id, paint: { 'fill-color': ['get', 'fill'], 'fill-opacity': 0.3 }, layout: { 'visibility': 'none' } }, layerIds.radar); 
                }
                if (!map.getLayer(`${source.id}-border`)) {
                    map.addLayer({ id: `${source.id}-border`, type: 'line', source: source.id, paint: { 'line-color': ['get', 'fill'], 'line-width': 2 }, layout: { 'visibility': 'none' } }, layerIds.radar); 
                }
            });

            if (!map.getLayer(layerIds.radarSites)) {
                map.addLayer({ 
                    id: layerIds.radarSites, 
                    type: 'circle', 
                    source: 'radar-sites', 
                    paint: { 
                        'circle-radius': 4, 
                        'circle-stroke-color': 'white', 
                        'circle-stroke-width': 1.5, 
                        'circle-color': [
                            'case',
                            ['==', ['get', 'isOffline'], true], '#ff0000', 
                            ['==', ['get', 'stationType'], 'WSR-88D'], '#0099ff',
                            ['==', ['get', 'stationType'], 'TDWR'], '#ff9900',
                            '#808080' 
                        ]
                    }, 
                    layout: { 'visibility': document.getElementById('radar-sites-toggle').checked ? 'visible' : 'none' } 
                });
            }
        }
        
        function updateSpcLayerVisibility() { 
            if (!map.isStyleLoaded()) return; 
            
            allSpcLayerIds.forEach(id => { 
                if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none'); 
            }); 
            
            if (activeSpcDay !== 'none') { 
                const layerToShow = layerIds.spc['day' + activeSpcDay][activeSpcType]; 
                if (layerToShow) { 
                    if (map.getLayer(layerToShow)) map.setLayoutProperty(layerToShow, 'visibility', 'visible'); 
                    if (map.getLayer(`${layerToShow}-border`)) map.setLayoutProperty(`${layerToShow}-border`, 'visibility', 'visible'); 
                }
            }
        }
        
        async function geocodeAndPlaceMarker() { const urlParams = new URLSearchParams(window.location.search); const locationParam = urlParams.get('l'); if (!locationParam) return; const formattedLocation = locationParam.replace(/-/g, ' '); const apiUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(formattedLocation)}&format=json&limit=1`; try { const response = await fetch(apiUrl, { headers: { 'User-Agent': 'TreeRadar-WebApp' } }); const data = await response.json(); if (data && data.length > 0) { const location = data[0]; const lon = parseFloat(location.lon); const lat = parseFloat(location.lat); new maplibregl.Marker({ color: "#FFC300", scale: 0.6 }).setLngLat([lon, lat]).addTo(map); map.flyTo({ center: [lon, lat], zoom: 9, essential: true }); } else { console.warn(`Could not find a location for: ${formattedLocation}`); } } catch (error) { console.error('Geocoding request failed:', error); } }

        const contextMenu = document.getElementById('context-menu');
        const contextMenuUl = contextMenu.querySelector('ul');
        const mainMenuHTML = contextMenuUl.innerHTML;
        let menuHistory = [];

        function showContextMenu(event) {
            event.preventDefault();

            contextMenuUl.innerHTML = mainMenuHTML;
            menuHistory = [];

            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;

            let x = event.clientX;
            let y = event.clientY;

            if (x + menuWidth > viewWidth) x = viewWidth - menuWidth;
            if (y + menuHeight > viewHeight) y = viewHeight - menuHeight;
            x = Math.max(0, x);
            y = Math.max(0, y);


            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';
        }

        function hideContextMenu() {
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                contextMenuUl.innerHTML = mainMenuHTML;
                menuHistory = [];
            }
        }

        function showRadarSiteMapPopup(site, coordinates) {
            closeAllPopups(); 

            const popupDiv = document.createElement('div');
            popupDiv.className = 'map-popup-base map-radar-popup-accent'; 

            const props = site.properties;
            const clickedStationId = props.id;
            const clickedStationIdLower = clickedStationId.toLowerCase();
            const name = props.name;
            const stationType = props.stationType;
            const isOffline = props.isOffline; 

            let accentColorHex = '#808080';
            if (isOffline) {
                accentColorHex = '#ff0000';
            } else if (stationType === 'WSR-88D') {
                accentColorHex = '#0099ff';
            } else if (stationType === 'TDWR') {
                accentColorHex = '#ff9900';
            }
            popupDiv.style.borderTop = `5px solid ${hexToRgba(accentColorHex, 0.5)}`;

            let buttonsHtml = '';
            if (stationType === 'TDWR') {
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'brefl')">Long Range Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'bref1')">Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'bvel')">Velocity</button></li>`;
            } else {
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'sr_bref')">Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'sr_bvel')">Velocity</button></li>`;
            }

            popupDiv.innerHTML = `
                <h4>${clickedStationId} - ${name}</h4>
                <div class="popup-content-area">
                    <ul>
                        ${buttonsHtml}
                    </ul>
                </div>
            `;

            currentMapPopup = new maplibregl.Popup({
                closeOnClick: true, 
                closeButton: false,
                anchor: 'bottom', 
                className: 'custom-map-popup-container' 
            })
            .setLngLat(coordinates)
            .setDOMContent(popupDiv)
            .addTo(map);

            currentMapPopup._container.addEventListener('contextmenu', disableContextMenu);
        }
        
        function formatSpcLabel(val) {
             if (!val) return 'N/A';
             const upperVal = val.toUpperCase();
             if (!isNaN(val) && !isNaN(parseFloat(val))) {
                 const num = parseFloat(val);
                 if (num < 1) {
                     return (num * 100).toString() + "%";
                 }
                 return val + "%";
             }
             
             if (upperVal === 'TSTM') return 'General Thunderstorms';
             if (upperVal === 'MRGL') return 'Marginal';
             if (upperVal === 'SLGT') return 'Slight';
             if (upperVal === 'ENH') return 'Enhanced';
             if (upperVal === 'MDT') return 'Moderate';
             if (upperVal === 'HIGH') return 'High';
             
             return val;
        }

        function showAlertMapPopup(items, clickedLngLat) {
            closeAllPopups(); 
            
            currentStackedAlertsOnMap = items;
            currentStackedAlertIndex = 0;

            const popupDiv = document.createElement('div');
            popupDiv.className = 'map-popup-base map-alert-popup-accent-top'; 

            const updatePopupContent = () => {
                const item = currentStackedAlertsOnMap[currentStackedAlertIndex];
                if (!item) {
                    closeAllPopups();
                    return;
                }

                const props = item.properties;
                let title, tagsHtml = '', accentColor;

                if (item.type === 'alert') {
                    const params = props.parameters || {};
                    title = props.specificEventName || props.event || "Weather Alert";
                    const baseEvent = props.event;
                    accentColor = alertColorMap[baseEvent] || '#808080';

                    const expireDate = parseApiDate(props.expires);
                    if (expireDate && !isNaN(expireDate.getTime())) {
                        const dateOptions = { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
                        const expireString = expireDate.toLocaleString('en-US', dateOptions);
                        tagsHtml += `<p><strong>Expires:</strong> ${expireString}</p>`;
                    }

                    const tornado = params.tornadoDetection ? params.tornadoDetection[0] : null;
                    if (tornado && formatThreatValue(tornado)) { tagsHtml += `<p><strong>Tornado:</strong> ${formatThreatValue(tornado)}</p>`; }
                    const waterspout = params.waterspoutDetection ? params.waterspoutDetection[0] : null;
                    if (waterspout && formatThreatValue(waterspout)) { tagsHtml += `<p><strong>Waterspout:</strong> ${formatThreatValue(waterspout)}</p>`; }
                    const damageThreat = params.tornadoDamageThreat?.[0] || params.thunderstormDamageThreat?.[0] || params.flashFloodDamageThreat?.[0];
                    if (damageThreat && formatThreatValue(damageThreat)) { tagsHtml += `<p><strong>Threat:</strong> ${formatThreatValue(damageThreat)}</p>`; }
                    
                    const windGust = params.maxWindGust ? params.maxWindGust[0] : null;
                    if (windGust && windGust !== '0 MPH' && formatThreatValue(windGust)) {
                        const windThreat = params.windThreat ? params.windThreat[0] : null;
                        let windText = windGust.replace("MPH", "mph");
                        if (windThreat && formatThreatValue(windThreat)) { windText += `, ${formatThreatValue(windThreat)}`; }
                        tagsHtml += `<p><strong>Winds:</strong> ${windText}</p>`;
                    }
                    
                    const hailSize = params.maxHailSize ? params.maxHailSize[0] : null;
                    if (hailSize && hailSize !== '0.00' && formatThreatValue(hailSize)) {
                        const hailThreat = params.hailThreat ? params.hailThreat[0] : null;
                        let hailText = hailSize + '"';
                        if (hailThreat && formatThreatValue(hailThreat)) { hailText += `, ${formatThreatValue(hailThreat)}`; }
                        tagsHtml += `<p><strong>Hail:</strong> ${hailText}</p>`;
                    }
                    
                    const flashFloodDetection = params.flashFloodDetection ? params.flashFloodDetection[0] : null;
                    if (flashFloodDetection && formatThreatValue(flashFloodDetection)) { tagsHtml += `<p><strong>Source:</strong> ${formatThreatValue(flashFloodDetection)}</p>`; }

                } else {
                    const dayLabel = `Day ${activeSpcDay}`;
                    let typeLabel = '';
                    
                    if (parseInt(activeSpcDay) >= 4) {
                        typeLabel = 'Probabilistic';
                    } else {
                        switch(activeSpcType) {
                            case 'cat': typeLabel = 'Categorical'; break;
                            case 'torn': typeLabel = 'Tornado'; break;
                            case 'hail': typeLabel = 'Hail'; break;
                            case 'wind': typeLabel = 'Wind'; break;
                            case 'prob': typeLabel = 'Probabilistic'; break;
                        }
                    }

                    title = `SPC ${dayLabel} ${typeLabel}`;
                    accentColor = item.properties.fill || '#FFFFFF';

                    const rawLabel = props.LABEL || props.LABEL2 || 'N/A';
                    const formattedLabel = formatSpcLabel(rawLabel);
                    
                    tagsHtml += `<p><strong>Risk:</strong> ${formattedLabel}</p>`;
                }

                popupDiv.style.borderTop = `5px solid ${hexToRgba(accentColor, 0.5)}`;

                let pagerHtml = '';
                if (currentStackedAlertsOnMap.length > 1) {
                    pagerHtml = '<div class="alert-pager">';
                    for (let i = 0; i < currentStackedAlertsOnMap.length; i++) {
                        pagerHtml += `<div class="pager-dot ${i === currentStackedAlertIndex ? 'active' : ''}" data-index="${i}"></div>`;
                    }
                    pagerHtml += '</div>';
                }

                popupDiv.innerHTML = `
                    <h4>${title}</h4>
                    <div class="popup-content-area">
                        ${tagsHtml}
                        <ul>
                            <li><button id="full-text-button">Full Text</button></li>
                        </ul>
                    </div>
                    ${pagerHtml}
                `;

                popupDiv.querySelector('#full-text-button').addEventListener('click', () => {
                    if (item.type === 'alert') {
                        showFullAlertTextPopup(item.feature);
                    } else {
                        showFullSpcTextPopup(item);
                    }
                });

                if (currentStackedAlertsOnMap.length > 1) {
                    popupDiv.querySelectorAll('.pager-dot').forEach(dot => {
                        dot.addEventListener('click', (e) => {
                            currentStackedAlertIndex = parseInt(e.target.dataset.index, 10);
                            updatePopupContent(); 
                        });
                    });
                }
            };
            
            updatePopupContent(); 

            let touchStartX = 0;
            let touchStartY = 0;
            let lastNavTime = 0;
            const NAV_COOLDOWN = 300; 

            const nextAlert = () => {
                const now = Date.now();
                if (now - lastNavTime < NAV_COOLDOWN) return;
                if (currentStackedAlertIndex < currentStackedAlertsOnMap.length - 1) {
                    currentStackedAlertIndex++;
                    updatePopupContent();
                    lastNavTime = now;
                }
            };

            const prevAlert = () => {
                const now = Date.now();
                if (now - lastNavTime < NAV_COOLDOWN) return;
                if (currentStackedAlertIndex > 0) {
                    currentStackedAlertIndex--;
                    updatePopupContent();
                    lastNavTime = now;
                }
            };

            popupDiv.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].clientX;
                touchStartY = e.changedTouches[0].clientY;
            }, {passive: true});

            popupDiv.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;

                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                    if (diffX > 0) nextAlert();
                    else prevAlert();
                }
            }, {passive: true});

            popupDiv.addEventListener('wheel', (e) => {
                if (currentStackedAlertsOnMap.length > 1) {
                    if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
                        e.preventDefault();
                        if (e.deltaX > 0) nextAlert();
                        else prevAlert();
                    } 
                    else {
                        const contentArea = popupDiv.querySelector('.popup-content-area');
                        if (contentArea.scrollHeight <= contentArea.clientHeight) {
                             e.preventDefault();
                             if (e.deltaY > 0) nextAlert();
                             else prevAlert();
                        }
                    }
                }
            }, { passive: false });

            let mouseDownX = 0;
            popupDiv.addEventListener('mousedown', (e) => {
                mouseDownX = e.clientX;
            });

            popupDiv.addEventListener('mouseup', (e) => {
                const mouseUpX = e.clientX;
                const diffX = mouseDownX - mouseUpX;
                if (Math.abs(diffX) > 50) {
                    if (diffX > 0) nextAlert();
                    else prevAlert();
                }
            });

            currentMapPopup = new maplibregl.Popup({
                closeOnClick: true,
                closeButton: false,
                anchor: 'bottom',
                className: 'custom-map-popup-container'
            })
            .setLngLat(clickedLngLat)
            .setDOMContent(popupDiv)
            .addTo(map);

            currentMapPopup._container.addEventListener('contextmenu', disableContextMenu);
        }

        function showFullAlertTextPopup(feature) {
            const props = feature.properties;
            const params = props.parameters || {};

            const overlay = document.getElementById('full-alert-text-popup-overlay');
            const contentDiv = document.getElementById('full-alert-text-content');
            const fullAlertPopupElement = document.getElementById('full-alert-text-popup');

            const alertTitle = props.specificEventName || props.event || "Weather Alert";
            const baseEvent = props.event; 
            
            const accentColor = alertColorMap[baseEvent] || '#808080';
            const rgbaAccentColor = hexToRgba(accentColor, 0.5);
            fullAlertPopupElement.style.borderLeft = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderTop = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderRight = `5px solid ${rgbaAccentColor}`;


            const issuedDate = parseApiDate(props.sent);
            const expireDate = parseApiDate(props.expires);
            const dateOptions = { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
            const issuedString = issuedDate && !isNaN(issuedDate.getTime()) ? issuedDate.toLocaleString('en-US', dateOptions) : ""; 
            const expireString = expireDate && !isNaN(expireDate.getTime()) ? expireDate.toLocaleString('en-US', dateOptions) : ""; 

            let fullHtml = `<h4>${alertTitle}</h4>`;
            
            let hasDateAffected = false;
            if (issuedString) { fullHtml += `<p><strong>Sent:</strong> ${issuedString}</p>`; hasDateAffected = true; }
            if (expireString) { fullHtml += `<p><strong>Expires:</strong> ${expireString}</p>`; hasDateAffected = true; }
            if (props.areaDesc && props.areaDesc.toUpperCase() !== 'N/A') {
                fullHtml += `<p><strong>Affected:</strong> ${props.areaDesc}</p>`; hasDateAffected = true;
            }
            if (hasDateAffected) { fullHtml += `<p>&nbsp;</p>`; } 

            let tagsHtmlContent = '';
            const tornado = params.tornadoDetection ? params.tornadoDetection[0] : null;
            if (tornado && formatThreatValue(tornado)) { tagsHtmlContent += `<p><strong>Tornado:</strong> ${formatThreatValue(tornado)}</p>`; }
            const waterspout = params.waterspoutDetection ? params.waterspoutDetection[0] : null;
            if (waterspout && formatThreatValue(waterspout)) { tagsHtmlContent += `<p><strong>Waterspout:</strong> ${formatThreatValue(waterspout)}</p>`; }
            const damageThreat = params.tornadoDamageThreat?.[0] || params.thunderstormDamageThreat?.[0] || params.flashFloodDamageThreat?.[0];
            if (damageThreat && formatThreatValue(damageThreat)) { tagsHtmlContent += `<p><strong>Threat:</strong> ${formatThreatValue(damageThreat)}</p>`; }
            
            const windGust = params.maxWindGust ? params.maxWindGust[0] : null;
            if (windGust && windGust !== '0 MPH' && formatThreatValue(windGust)) {
                const windThreat = params.windThreat ? params.windThreat[0] : null;
                let windText = windGust.replace("MPH", "mph");
                if (windThreat && formatThreatValue(windThreat)) { windText += `, ${formatThreatValue(windThreat)}`; }
                tagsHtmlContent += `<p><strong>Winds:</strong> ${windText}</p>`;
            }
            
            const hailSize = params.maxHailSize ? params.maxHailSize[0] : null;
            if (hailSize && hailSize !== '0.00' && formatThreatValue(hailSize)) {
                const hailThreat = params.hailThreat ? params.hailThreat[0] : null;
                let hailText = hailSize + '"';
                if (hailThreat && formatThreatValue(hailThreat)) { hailText += `, ${formatThreatValue(hailThreat)}`; }
                tagsHtmlContent += `<p><strong>Hail:</strong> ${hailText}</p>`;
            }
            const flashFloodDetection = params.flashFloodDetection ? params.flashFloodDetection[0] : null;
            if (flashFloodDetection && formatThreatValue(flashFloodDetection)) { tagsHtmlContent += `<p><strong>Source:</strong> ${formatThreatValue(flashFloodDetection)}</p>`; }
            
            if (tagsHtmlContent) {
                fullHtml += tagsHtmlContent + `<p>&nbsp;</p>`; 
            }

            let descriptionText = (props.description || "").replace(/\n/g, '<br>').trim();
            if (descriptionText) {
                fullHtml += `<p><strong>Description:</strong></p><p>${descriptionText}</p>`;
            }
            
            let instructionText = (props.instruction || "").replace(/\n/g, '<br>').trim();
            if (instructionText && instructionText.toUpperCase() !== 'N/A') {
                fullHtml += `<p>&nbsp;</p><p><strong>Instructions:</strong></p><p>${instructionText}</p>`;
            }

            contentDiv.innerHTML = fullHtml;
            overlay.style.display = 'flex'; 
        }
        
        async function showFullSpcTextPopup(item) {
            const overlay = document.getElementById('full-alert-text-popup-overlay');
            const contentDiv = document.getElementById('full-alert-text-content');
            const fullAlertPopupElement = document.getElementById('full-alert-text-popup');
            
            const accentColor = item.properties.fill || '#FFFFFF';
            const rgbaAccentColor = hexToRgba(accentColor, 0.5);
            fullAlertPopupElement.style.borderLeft = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderTop = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderRight = `5px solid ${rgbaAccentColor}`;

            contentDiv.innerHTML = `<h4>SPC Day ${activeSpcDay} Discussion</h4><p>Loading forecast text...</p>`;
            overlay.style.display = 'flex';

            const text = await fetchSpcOutlookText(activeSpcDay);
            
            contentDiv.innerHTML = `
                <h4>SPC Day ${activeSpcDay} Discussion</h4>
                <pre>${text}</pre>
            `;
        }

        document.addEventListener('contextmenu', showContextMenu);
        document.addEventListener('click', hideContextMenu);
        
        map.on('load', async () => {
            await setupMapData();
            updateSpcLayerVisibility();
            geocodeAndPlaceMarker(); 
            
            checkRadarStatus();
            setInterval(checkRadarStatus, 300000);

            contextMenuUl.addEventListener('click', (e) => {
                const targetLi = e.target.closest('li');
                if (!targetLi) return;

                e.stopPropagation();

                if (targetLi.id === 'context-menu-back') {
                    const previousMenuHTML = menuHistory.pop();
                    if (previousMenuHTML) {
                        contextMenuUl.innerHTML = previousMenuHTML;
                    }
                    return;
                }

                const submenu = targetLi.querySelector('.context-submenu');
                if (submenu) {
                    menuHistory.push(contextMenuUl.innerHTML);
                    const submenuUl = submenu.querySelector('ul');
                    if (submenuUl) {
                        contextMenuUl.innerHTML = `<li id="context-menu-back"><div class="menu-item-text"><i class="material-symbols-rounded">arrow_back</i>Back</div></li>` + submenuUl.innerHTML;
                    }
                    return;
                }

                if (targetLi.classList.contains('outlook-type')) {
                    activeSpcDay = targetLi.dataset.day;
                    activeSpcType = targetLi.dataset.type;
                    updateSpcLayerVisibility();
                    hideContextMenu();
                }

                switch (targetLi.id) {
                    case 'context-menu-mosaic':
                        const radarToggle = document.getElementById('radar-toggle');
                        radarToggle.checked = !radarToggle.checked;
                        updateMosaicVisibility();
                        hideContextMenu();
                        break;
                    case 'context-menu-alerts':
                        const alertsToggle = document.getElementById('alerts-toggle');
                        const newState = !alertsToggle.checked;
                        alertsToggle.checked = newState;
                        const v = newState ? 'visible' : 'none';
                        const alertLayers = [layerIds.alertsZone, layerIds.alertsZoneBorder, layerIds.alertsPolygon, layerIds.alertsPolygonBorder];
                        alertLayers.forEach(layerId => {
                            if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', v);
                        });
                        hideContextMenu();
                        break;
                    case 'context-menu-sites':
                        const sitesToggle = document.getElementById('radar-sites-toggle');
                        sitesToggle.checked = !sitesToggle.checked;
                        if (map.getLayer(layerIds.radarSites)) map.setLayoutProperty(layerIds.radarSites, 'visibility', sitesToggle.checked ? 'visible' : 'none');
                        hideContextMenu();
                        break;
                }
            });
            
            updateAlerts();

            updateIntervalId = setInterval(updateAlerts, 60000);
            setInterval(updateRadar, 60000); 
            setInterval(updateSingleSiteRadar, 45000);
            setInterval(updateSpcOutlooks, 600000);

            map.on('mouseup', (e) => {
                if (e.originalEvent.button !== 1) {
                    return;
                }
                
                e.preventDefault();
                closeAllPopups(); 

                if (!allRadarSitesData || allRadarSitesData.length === 0) return;

                let nearestSite = null;
                let minDistance = Infinity;
                const clickPoint = e.lngLat;
                allRadarSitesData.forEach(site => {
                    if (site.geometry && site.geometry.coordinates) {
                        const sitePoint = new maplibregl.LngLat(site.geometry.coordinates[0], site.geometry.coordinates[1]);
                        const distance = clickPoint.distanceTo(sitePoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestSite = site;
                        }
                    }
                });

                if (nearestSite) {
                    const targetSiteType = nearestSite.properties.stationType;
                    const targetSiteId = nearestSite.properties.id.toLowerCase();
                    const coordinates = nearestSite.geometry.coordinates.slice();

                    let targetProduct = null;

                    const isMosaicMode = !activeSiteIdForData;
                    const currentProduct = activeRadarProductCode;
                    
                    if (isMosaicMode) {
                        targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                    } else {
                        switch (currentProduct) {
                            case 'sr_bvel':
                            case 'bvel':
                                targetProduct = (targetSiteType === 'TDWR') ? 'bvel' : 'sr_bvel';
                                break;
                            
                            case 'sr_bref':
                            case 'bref1':
                                targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                                break;

                            case 'brefl':
                                targetProduct = (targetSiteType === 'TDWR') ? 'brefl' : 'sr_bref';
                                break;
                            
                            default:
                                targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                                break;
                        }
                    }

                    map.flyTo({ center: coordinates, zoom: 7.5, speed: 1.5, curve: 1.4, essential: true });
                    
                    if (targetProduct && (activeSiteIdForData !== targetSiteId || activeRadarProductCode !== targetProduct)) {
                         toggleRadarProduct(targetSiteId, targetProduct);
                    }
                }
            });
        });

        map.on('style.load', async () => {
            await setupMapData();
            updateSpcLayerVisibility();
            geocodeAndPlaceMarker();
            checkRadarStatus();
        });
        
        map.on('click', (e) => {
            const clickableLayers = [layerIds.radarSites, layerIds.alertsZone, layerIds.alertsPolygon, ...allSpcLayerIds]; 
            const features = map.queryRenderedFeatures(e.point, { layers: clickableLayers });
            closeAllPopups(); 
            if (!features.length) return;
            
            const topFeature = features[0];
            const props = topFeature.properties;

            if (topFeature.layer.id === layerIds.radarSites) {
                const clickedStationId = props.id;
                const nearestSite = allRadarSitesData.find(site => site.properties.id === clickedStationId);
                if (nearestSite) {
                    if (activeSiteIdForMenu === clickedStationId) { closeAllPopups(); return; }
                    const clickedStationIdLower = clickedStationId.toLowerCase();
                    if (activeSiteIdForData && activeSiteIdForData !== clickedStationIdLower) { removeSingleSiteLayer(); activeRadarProductCode = null; activeSiteIdForData = null; }
                    activeSiteIdForMenu = clickedStationId;
                    const coordinates = topFeature.geometry.coordinates.slice();
                    map.flyTo({ center: coordinates, zoom: 7.5, speed: 1.5, curve: 1.4, essential: true });
                    map.once('moveend', () => {
                        if (activeSiteIdForMenu !== clickedStationId) return;
                        showRadarSiteMapPopup(nearestSite, coordinates); 
                    });
                }
            } else {
                const allCurrentAlerts = [...globalPolyAlerts, ...globalZoneAlerts];
                const alertsAtClickPoint = map.queryRenderedFeatures(e.point, { layers: [layerIds.alertsZone, layerIds.alertsPolygon] })
                                            .map(f => {
                                                const found = allCurrentAlerts.find(alert => alert.properties.id === f.properties.id);
                                                return found ? { type: 'alert', feature: found, properties: found.properties } : null;
                                            })
                                            .filter(Boolean);
                                            
                const uniqueAlerts = [];
                const seenAlertIds = new Set();
                alertsAtClickPoint.forEach(item => {
                    if (!seenAlertIds.has(item.properties.id)) {
                        seenAlertIds.add(item.properties.id);
                        uniqueAlerts.push(item);
                    }
                });
                
                const outlooksAtClickPoint = [];
                if (activeSpcDay !== 'none') {
                     const spcFeatures = map.queryRenderedFeatures(e.point, { layers: allSpcLayerIds });
                     spcFeatures.forEach(f => {
                         outlooksAtClickPoint.push({ type: 'outlook', feature: f, properties: f.properties });
                     });
                }
                
                const uniqueOutlooks = [];
                const seenOutlookLabels = new Set();
                outlooksAtClickPoint.forEach(item => {
                    const key = `${item.properties.LABEL}_${item.properties.DN}`;
                    if (!seenOutlookLabels.has(key)) {
                        seenOutlookLabels.add(key);
                        uniqueOutlooks.push(item);
                    }
                });

                const stackedItems = [...uniqueAlerts, ...uniqueOutlooks];

                if (stackedItems.length > 0) {
                    showAlertMapPopup(stackedItems, e.lngLat);
                }
            }
        });

        const alertHoverLayers = [layerIds.alertsZone, layerIds.alertsPolygon];
        map.on('mouseenter', alertHoverLayers, () => { map.getCanvas().style.cursor = 'pointer'; });
        map.on('mouseleave', alertHoverLayers, () => { map.getCanvas().style.cursor = ''; });
        map.on('mouseenter', layerIds.radarSites, () => { map.getCanvas().style.cursor = 'pointer'; });
        map.on('mouseleave', layerIds.radarSites, () => { map.getCanvas().style.cursor = ''; });
        
        map.on('mouseenter', allSpcLayerIds, () => { map.getCanvas().style.cursor = 'pointer'; });
        map.on('mouseleave', allSpcLayerIds, () => { map.getCanvas().style.cursor = ''; });
        
        document.addEventListener('keydown', (event) => {
            if (!event.shiftKey || !activeSiteIdForData) {
                return;
            }

            const siteData = allRadarSitesData.find(site => site.properties.id.toLowerCase() === activeSiteIdForData);
            if (!siteData) return;

            const stationType = siteData.properties.stationType;
            let newProduct = null;

            switch (event.key.toUpperCase()) {
                case 'R':
                    event.preventDefault();
                    newProduct = (stationType === 'TDWR') ? 'bref1' : 'sr_bref';
                    break;
                case 'V':
                    event.preventDefault();
                    newProduct = (stationType === 'TDWR') ? 'bvel' : 'sr_bvel';
                    break;
                case 'L':
                    if (stationType === 'TDWR') {
                        event.preventDefault();
                        newProduct = 'brefl';
                    }
                    break;
            }

            if (newProduct && newProduct !== activeRadarProductCode) {
                toggleRadarProduct(activeSiteIdForData, newProduct);
            }
        });

    </script>
</body>
</html>
