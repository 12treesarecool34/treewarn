<!DOCTYPE html>
<html>
<head>
    <title>TreeRadar (v3.1, Beta)</title>
    <link rel="icon" href="https://raw.githubusercontent.com/microsoft/fluentui-emoji/refs/heads/main/assets/Deciduous%20tree/3D/deciduous_tree_3d.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' rel='stylesheet' />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; /* Prevent scrollbars */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* For Safari */
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        /* --- UNIFIED "GLASS" STYLE --- */
        .context-menu, .alert-popup, .map-popup-base {
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; /* Ensure text color is white by default for these */
            border-radius: 10px;
            font-family: 'Outfit', sans-serif; /* Consistent font */
        }

        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            width: max-content;
            overflow: visible;
            padding: 4px;
        }

        .context-submenu { display: none; }
        
        .context-menu ul { list-style: none; padding: 0; margin: 0; min-width: 150px; }
        .context-menu ul li {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            cursor: pointer;
            user-select: none;
            border-radius: 6px;
        }
        .context-menu .material-symbols-rounded { padding-right: 10px; }
        .context-menu ul li .menu-item-text { display: flex; align-items: center; }
        .context-menu ul li:hover { background-color: rgba(255, 255, 255, 0.1); }
        
        /* Maplibre-gl popup overrides */
        .maplibregl-popup-content {
            background: none;
            box-shadow: none;
            padding: 0;
            border-radius: 10px;
        }
        .maplibregl-popup-tip { display: none; }
        /* Maplibre default close button - only used for full text popup now */
        .maplibregl-popup-close-button {
            top: 5px;
            right: 5px;
            font-size: 20px;
            z-index: 1;
            color: #ccc;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .maplibregl-popup-close-button:hover {
            color: #fff;
        }

        /* New styling for custom maplibre-gl popups */
        .map-popup-base { 
            padding: 0; 
            font-size: 14px;
            min-width: 150px; /* Same min-width as context-menu */
            overflow: hidden; /* For border-radius on child elements */
        }

        .map-popup-base h4 {
            margin: 0; 
            padding: 10px;
            font-size: 18px;
            text-align: center;
            /* No border-bottom for dash-spacer removal */
        }
        .map-popup-base .popup-content-area {
            padding: 4px; /* Padding for the main content block, matching context menu overall padding */
        }
        .map-popup-base ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .map-popup-base ul li {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center; 
            padding: 10px; /* Padding for buttons */
            cursor: pointer;
            user-select: none;
            border-radius: 6px; 
            font-size: 14px;
        }
        .map-popup-base ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .map-popup-base ul li button {
            background: none;
            border: none;
            color: inherit; /* Inherit color from parent li */
            font: inherit; /* Inherit font from parent li */
            padding: 0;
            margin: 0;
            cursor: pointer;
            width: 100%;
            text-align: center;
            font-size: inherit; /* Explicitly inherit font size */
        }
        .map-popup-base ul li button:focus {
            outline: none;
        }
        .map-popup-base .popup-content-area p {
            margin: 8px 10px; /* Padding for content paragraphs */
            white-space: normal;
        }
        .map-popup-base .popup-content-area p:first-of-type {
            margin-top: 10px; 
        }
        .map-popup-base .popup-content-area p:last-of-type {
            margin-bottom: 10px; 
        }

        /* Specific accent classes will have their border-top set via JS */
        .map-radar-popup-accent { }
        .map-alert-popup-accent-top { }

        /* Style for the pager dots container - Removed from unified glass style */
        .alert-pager {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 25px;
            border-radius: 0 0 10px 10px;
        }
        .alert-pager .pager-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white for inactive */
            margin: 0 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .alert-pager .pager-dot.active {
            background-color: rgba(255, 255, 255, 1); /* Solid white for active */
        }

        /* Styling for the Full Alert Text Popup */
        #full-alert-text-popup-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6); 
            z-index: 2000; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #full-alert-text-popup {
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 10px;
            padding: 15px; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 400px; 
            max-height: 80vh; 
            overflow-y: scroll; 
            -ms-overflow-style: none;  
            scrollbar-width: none;  
            /* Borders will be set dynamically in JS */
            position: relative; 
        }

        #full-alert-text-popup::-webkit-scrollbar {
            display: none; 
        }

        #full-alert-text-popup h4 {
            margin: 0 0 10px 0; 
            font-size: 24px;
            text-align: center;
        }

        #full-alert-text-popup p {
            margin: 5px 0;
            font-size: 16px;
            line-height: 1.4;
        }
        #full-alert-text-popup strong {
            font-weight: bold;
        }
        /* --- Attribution Bubble --- */
        #attribution-bubble {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            display: flex;
            flex-direction: row-reverse; /* Puts icon on the right */
            align-items: center;
            justify-content: center;
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            height: 30px;
            width: 30px;
            border-radius: 15px;
            box-sizing: border-box;
            cursor: pointer;
            overflow: hidden;
        }
        #attribution-bubble:hover {
            background: rgba(40, 40, 40, 0.7);
        }
        #attribution-bubble.expanded {
            width: auto;
            padding: 0 4px; /* Symmetrical padding */
        }
        #attribution-bubble .material-symbols-rounded {
            font-size: 20px;
            flex-shrink: 0;
        }
        #attribution-bubble .attribution-text {
            display: none;
            margin-right: 8px; /* Space between text and icon */
            font-size: 14px;
            white-space: nowrap;
        }
        #attribution-bubble.expanded .attribution-text {
            display: block;
        }
        #attribution-bubble .attribution-text a {
            color: inherit;
            text-decoration: none;
        }
        #attribution-bubble .attribution-text a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="attribution-bubble">
        <i class="material-symbols-rounded">info</i>
        <div class="attribution-text">
            <a href="https://maplibre.org/" target="_blank">MapLibre</a> | <a href="https://carto.com/about-carto/" target="_blank">CARTO</a>, 
            <a href="https://mesonet.agron.iastate.edu/" target="_blank">IEM</a>, 
            <a href="https://noaa.gov/" target="_blank">NOAA/NWS</a>
        </div>
    </div>

    <div style="display: none;">
        <input type="checkbox" id="radar-toggle" checked>
        <input type="checkbox" id="alerts-toggle" checked>
        <input type="checkbox" id="radar-sites-toggle" checked>
    </div>
    
    <div id="context-menu" class="context-menu">
        <ul>
            <li id="context-menu-outlooks-parent">
                <div class="menu-item-text"><i class="material-symbols-rounded">map</i>Outlooks</div>
                <div class="context-submenu">
                    <ul>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_1</i>Day 1</div>
                            <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="1" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="1" data-type="torn"><div class="menu-item-text"><i class="material-symbols-rounded">tornado</i>Tornado</div></li>
                                    <li class="outlook-type" data-day="1" data-type="hail"><div class="menu-item-text"><i class="material-symbols-rounded">weather_hail</i>Hail</div></li>
                                    <li class="outlook-type" data-day="1" data-type="wind"><div class="menu-item-text"><i class="material-symbols-rounded">air</i>Wind</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_2</i>Day 2</div>
                            <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="2" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="2" data-type="torn"><div class="menu-item-text"><i class="material-symbols-rounded">tornado</i>Tornado</div></li>
                                    <li class="outlook-type" data-day="2" data-type="hail"><div class="menu-item-text"><i class="material-symbols-rounded">weather_hail</i>Hail</div></li>
                                    <li class="outlook-type" data-day="2" data-type="wind"><div class="menu-item-text"><i class="material-symbols-rounded">air</i>Wind</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">counter_3</i>Day 3</div>
                             <div class="context-submenu">
                                <ul>
                                    <li class="outlook-type" data-day="3" data-type="cat"><div class="menu-item-text"><i class="material-symbols-rounded">thunderstorm</i>Categorical</div></li>
                                    <li class="outlook-type" data-day="3" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                </ul>
                            </div>
                        </li>
                        <li>
                            <div class="menu-item-text"><i class="material-symbols-rounded">add_circle</i>Day 4-8</div>
                            <div class="context-submenu">
                                <ul>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_4</i>Day 4</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="4" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_5</i>Day 5</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="5" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_6</i>Day 6</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="6" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_7</i>Day 7</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="7" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li>
                                        <div class="menu-item-text"><i class="material-symbols-rounded">counter_8</i>Day 8</div>
                                        <div class="context-submenu">
                                            <ul>
                                                <li class="outlook-type" data-day="8" data-type="prob"><div class="menu-item-text"><i class="material-symbols-rounded">percent</i>Probabilistic</div></li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </li>
                        <li class="outlook-type" data-day="none" data-type="none"><div class="menu-item-text"><i class="material-symbols-rounded">cancel</i>None</div></li>
                    </ul>
                </div>
            </li>
            <li id="context-menu-mosaic"><div class="menu-item-text"><i class="material-symbols-rounded">radar</i>Mosaic</div></li>
            <li id="context-menu-alerts"><div class="menu-item-text"><i class="material-symbols-rounded">warning</i>Alerts</div></li>
            <li id="context-menu-sites"><div class="menu-item-text"><i class="material-symbols-rounded">location_on</i>Sites</div></li>
        </ul>
    </div>

    <script>
        // Function to prevent context menu
        function disableContextMenu(event) {
            event.stopPropagation();
            event.preventDefault();
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Disable context menu on static UI elements
            document.getElementById('context-menu').addEventListener('contextmenu', disableContextMenu);

            document.getElementById('attribution-bubble').addEventListener('contextmenu', disableContextMenu);
            
            // Setup for the Full Alert Text Popup overlay
            const fullAlertOverlay = document.createElement('div');
            fullAlertOverlay.id = 'full-alert-text-popup-overlay';
            fullAlertOverlay.innerHTML = `
                <div id="full-alert-text-popup">
                    <button class="maplibregl-popup-close-button" type="button" aria-label="Close popup" aria-hidden="true">Ã—</button>
                    <div id="full-alert-text-content"></div>
                </div>
            `;
            document.body.appendChild(fullAlertOverlay);
            fullAlertOverlay.addEventListener('contextmenu', disableContextMenu);
            // Explicitly ensure the overlay is hidden on load
            fullAlertOverlay.style.display = 'none'; 


            // Add listener to the close button of the full alert text popup
            document.querySelector('#full-alert-text-popup .maplibregl-popup-close-button').addEventListener('click', () => {
                document.getElementById('full-alert-text-popup-overlay').style.display = 'none';
            });


            
            // Attribution bubble logic
            const attributionBubble = document.getElementById('attribution-bubble');
            attributionBubble.addEventListener('click', (event) => {
                event.stopPropagation();
                attributionBubble.classList.toggle('expanded');
            });
        });

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            center: [-97, 39],
            zoom: 2.75,
            attributionControl: false
        });

        const layerIds = {
            radar: 'weather-radar-layer',
            alertsZone: 'alerts-zone-layer',
            alertsZoneBorder: 'alerts-zone-border-layer',
            alertsPolygon: 'alerts-polygon-layer',
            alertsPolygonBorder: 'alerts-polygon-border-layer',
            radarSites: 'nws-radar-sites-layer',
            singleSiteRadar: 'single-site-radar-layer',
            spc: {
                day1: { cat: 'spc-day1-cat', torn: 'spc-day1-torn', hail: 'spc-day1-hail', wind: 'spc-day1-wind' },
                day2: { cat: 'spc-day2-cat', torn: 'spc-day2-torn', hail: 'spc-day2-hail', wind: 'spc-day2-wind' },
                day3: { cat: 'spc-day3-cat', prob: 'spc-day3-prob' },
                day4: { prob: 'spc-day4-prob' },
                day5: { prob: 'spc-day5-prob' },
                day6: { prob: 'spc-day6-prob' },
                day7: { prob: 'spc-day7-prob' },
                day8: { prob: 'spc-day8-prob' }
            }
        };
        
        let activeSpcDay = 'none';
        let activeSpcType = 'none';
        let countyDataMap = new Map();
        let ugcGeoCache = new Map();

        let activeSiteIdForMenu = null, activeSiteIdForData = null, activeRadarProductCode = null;
        let currentMapPopup = null; 
        let allRadarSitesData = []; 

        let currentStackedAlertsOnMap = []; 
        let currentStackedAlertIndex = 0;

        const alertColorMap = {
            'Catastrophic Tornado': '#9900FF',
            'Considerable Tornado': '#FF00FF',
            'Confirmed Tornado': '#FF0000',
            'Destructive Thunderstorm': '#FF6600',
            'Confirmed Waterspout': '#FFFF00',
            'Tornado Warning': '#FF0000',
            'Catastrophic Flash Flood': '#008855',
            'Considerable Thunderstorm': '#FFAA00',
            'Tornado Possible': '#FFAA00',
            'Waterspout Possible': '#FFFF00',
            'Severe Thunderstorm Warning': '#FFAA00',
            'Considerable Flash Flood': '#008855',
            'Severe Weather Statement': '#00FFFF',
            'Storm Warning': '#FFBB33',
            'Special Marine Warning': '#FFFF00',
            'Special Weather Statement': '#00FFFF',
            'Marine Weather Statement': '#FFFF00',
            'Tornado Watch': '#880000',
            'Severe Thunderstorm Watch': '#556B2F',
            'Storm Watch': '#FFBB33',
            'Flash Flood Warning': '#008888',
            'Flood Warning': '#008800',
            'Coastal Flood Warning': '#008800',
            'Flood Advisory': '#008800',
            'Coastal Flood Advisory': '#008800',
            'Flash Flood Statement': '#008888',
            'Flood Statement': '#008800',
            'Coastal Flood Statement': '#008800',
            'Flash Flood Watch': '#008888',
            'Flood Watch': '#008800',
            'Coastal Flood Watch': '#008800',
            'Blizzard Warning': '#FF22FF',
            'Snow Squall Warning': '#5555FF',
            'Winter Storm Warning': '#FF4444',
            'Winter Weather Advisory': '#8888FF',
            'Winter Storm Watch': '#FF8888'
        };

        const whitelistedEvents = new Set([
            'Tornado Warning', 'Severe Thunderstorm Warning', 'Tornado Watch', 'Severe Thunderstorm Watch',
            'Severe Weather Statement', 'Special Weather Statement', 'Storm Warning', 'Storm Watch',
            'Special Marine Warning', 'Marine Weather Statement', 'Flash Flood Warning', 'Flash Flood Watch',
            'Flash Flood Statement', 'Flood Warning', 'Flood Watch', 'Flood Advisory', 'Flood Statement',
            'Coastal Flood Advisory', 'Coastal Flood Statement', 'Coastal Flood Warning', 'Coastal Flood Watch',
            'Blizzard Warning', 'Winter Storm Warning', 'Winter Weather Advisory', 'Winter Storm Watch',
            'Snow Squall Warning'
        ]);

        let allActiveAlerts = [];

        const baseSpcLayerIds = Object.values(layerIds.spc).flatMap(day => Object.values(day));
        const allSpcLayerIds = baseSpcLayerIds.flatMap(id => [id, `${id}-border`]);

        const spcSources = [
            { id: layerIds.spc.day1.cat, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day1.torn, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day1.hail, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day1.wind, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day2.cat, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day2.torn, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day2.hail, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day2.wind, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day3.cat, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day3.prob, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_prob.nolyr.geojson' },
            { id: layerIds.spc.day4.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day4prob.nolyr.geojson' },
            { id: layerIds.spc.day5.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day5prob.nolyr.geojson' },
            { id: layerIds.spc.day6.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day6prob.nolyr.geojson' },
            { id: layerIds.spc.day7.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day7prob.nolyr.geojson' },
            { id: layerIds.spc.day8.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day8prob.nolyr.geojson' }
        ];

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function parseApiDate(dateString) {
            return new Date(dateString);
        }
        
        function getSpecificAlertName(props) {
            const event = props.event;
            const params = props.parameters || {};

            if (event === 'Tornado Warning') {
                const threat = params.tornadoDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Tornado';
                if (threat === 'CONSIDERABLE') return 'Considerable Tornado';
                if (params.tornadoDetection?.[0] === 'OBSERVED') return 'Confirmed Tornado';
            }
            if (event === 'Severe Thunderstorm Warning') {
                const threat = params.thunderstormDamageThreat?.[0];
                if (threat === 'DESTRUCTIVE') return 'Destructive Thunderstorm';
                if (threat === 'CONSIDERABLE') return 'Considerable Thunderstorm';
                if (params.tornadoDetection?.[0] === 'POSSIBLE') return 'Tornado Possible';
            }
            if (event === 'Special Marine Warning' || event === 'Marine Weather Statement') {
                 const threat = params.waterspoutDetection?.[0];
                 if (threat === 'OBSERVED') return 'Confirmed Waterspout';
                 if (threat === 'POSSIBLE') return 'Waterspout Possible';
            }
            if (event === 'Flash Flood Warning') {
                const threat = params.flashFloodDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Flash Flood';
                if (threat === 'CONSIDERABLE') return 'Considerable Flash Flood';
            }

            return event;
        }
        
        function isValidAlert(feature) {
            const props = feature.properties;
            if (!props) return false;

            if (!whitelistedEvents.has(props.event)) return false;
            
            if (props.parameters && props.parameters.VTEC && props.parameters.VTEC[0] && props.parameters.VTEC[0].startsWith("/O.CAN.")) {
                return false;
            }
            
            return true;
        }

        function formatThreatValue(value) {
            if (!value || typeof value !== 'string') return '';
            const cleanedValue = value.toUpperCase() === 'N/A' ? '' : value;
            if (!cleanedValue) return '';
            return cleanedValue.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        function updateMosaicVisibility() {
            const mosaicToggle = document.getElementById('radar-toggle');
            const isMosaicEnabledByUser = mosaicToggle.checked;
            const isSiteRadarActive = map.getLayer(layerIds.singleSiteRadar);

            if (map.getLayer(layerIds.radar)) {
                if (isSiteRadarActive) {
                    map.setLayoutProperty(layerIds.radar, 'visibility', 'none');
                } else {
                    map.setLayoutProperty(layerIds.radar, 'visibility', isMosaicEnabledByUser ? 'visible' : 'none');
                }
            }
        }

        function removeSingleSiteLayer() {
            if (map.getLayer(layerIds.singleSiteRadar)) map.removeLayer(layerIds.singleSiteRadar);
            if (map.getSource('single-site-radar-source')) map.removeSource('single-site-radar-source');
        }

        function closeAllPopups() {
            const maplibrePopups = document.querySelectorAll('.maplibregl-popup');
            maplibrePopups.forEach(popup => popup.remove());

            activeSiteIdForMenu = null;
            currentMapPopup = null; 
            currentStackedAlertsOnMap = [];
            currentStackedAlertIndex = 0;
            document.getElementById('full-alert-text-popup-overlay').style.display = 'none';
        }
        
        function toggleRadarProduct(stationId, productCode) {
            const isTogglingOff = activeSiteIdForData === stationId && activeRadarProductCode === productCode;
            removeSingleSiteLayer();
            if (isTogglingOff) {
                activeRadarProductCode = null;
                activeSiteIdForData = null;
            } else {
                activeRadarProductCode = productCode;
                activeSiteIdForData = stationId;
                const tileUrl = `https://opengeo.ncep.noaa.gov/geoserver/${stationId}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${stationId}_${productCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}`;
                map.addSource('single-site-radar-source', { 'type': 'raster', 'tiles': [tileUrl], 'tileSize': 256, 'attribution': 'Radar data from NOAA' });
                map.addLayer({ 'id': layerIds.singleSiteRadar, 'type': 'raster', 'source': 'single-site-radar-source', 'paint': {} }, layerIds.alertsZone); 
            }
            updateMosaicVisibility();
        }

        async function updateAlerts() {
            try {
                const response = await fetch('https://api.weather.gov/alerts/active?status=actual&message_type=alert,update');
                if (!response.ok) throw new Error(`NWS API fetch error: ${response.statusText}`);
                const data = await response.json();

                const promises = data.features
                    .filter(isValidAlert)
                    .map(async (feature) => {
                        const props = feature.properties;
                        feature.properties.specificEventName = getSpecificAlertName(props);

                        if (feature.geometry) {
                            feature.properties.geometryType = 'polygon';
                            return feature;
                        }

                        let alertGeometries = [];
                        if (props.geocode && props.geocode.UGC && props.geocode.UGC.length > 0) {
                            for (const ugcCode of props.geocode.UGC) {
                                if (ugcGeoCache.has(ugcCode)) {
                                    const cachedGeo = ugcGeoCache.get(ugcCode);
                                    if (cachedGeo) {
                                         if (cachedGeo.type === 'Polygon') alertGeometries.push(cachedGeo.coordinates);
                                         else if (cachedGeo.type === 'MultiPolygon') alertGeometries.push(...cachedGeo.coordinates);
                                    }
                                    continue;
                                }

                                const type = ugcCode.charAt(2).toUpperCase() === 'C' ? 'county' : 'forecast';
                                const url = `https://api.weather.gov/zones/${type}/${ugcCode}`;

                                try {
                                    const zoneResponse = await fetch(url);
                                    if (!zoneResponse.ok) throw new Error(`Failed to fetch UGC zone for ${ugcCode}`);
                                    const zoneData = await zoneResponse.json();
                                    
                                    if (zoneData.geometry) {
                                        ugcGeoCache.set(ugcCode, zoneData.geometry);
                                        if (zoneData.geometry.type === 'Polygon') alertGeometries.push(zoneData.geometry.coordinates);
                                        else if (zoneData.geometry.type === 'MultiPolygon') alertGeometries.push(...zoneData.geometry.coordinates);
                                    } else {
                                        ugcGeoCache.set(ugcCode, null);
                                    }
                                } catch (error) {
                                    console.error(error);
                                    ugcGeoCache.set(ugcCode, null);
                                }
                            }
                        }

                        if (alertGeometries.length === 0 && props.geocode && props.geocode.SAME) {
                            props.geocode.SAME.forEach(fipsCode => {
                                const countyFIPS = fipsCode.substring(1);
                                const countyFeature = countyDataMap.get(countyFIPS);
                                if (countyFeature && countyFeature.geometry) {
                                    if (countyFeature.geometry.type === 'Polygon') alertGeometries.push(countyFeature.geometry.coordinates);
                                    else if (countyFeature.geometry.type === 'MultiPolygon') alertGeometries.push(...countyFeature.geometry.coordinates);
                                }
                            });
                        }

                        if (alertGeometries.length > 0) {
                            return {
                                type: 'Feature',
                                geometry: { type: 'MultiPolygon', coordinates: alertGeometries },
                                properties: { ...props, geometryType: 'zone' }
                            };
                        }
                        
                        return null;
                    });

                const featuresToDisplay = (await Promise.all(promises)).filter(Boolean);
                
                if (map.getSource('alerts')) {
                    map.getSource('alerts').setData({ type: 'FeatureCollection', features: featuresToDisplay });
                }

                allActiveAlerts = featuresToDisplay;

            } catch (e) {
                console.error("Alerts Fetch ERR:", e);
            }
        }


        // Function to check individual radar site status
        async function checkRadarStatus() {
            console.log("Checking radar statuses...");
            const now = Date.now();
            const twentyMinutesAgo = now - (20 * 60 * 1000); 
            let changedStatus = false;
            
            const updatedRadarSitesData = [...allRadarSitesData];

            for (let i = 0; i < updatedRadarSitesData.length; i++) {
                const site = updatedRadarSitesData[i];
                const radarId = site.properties.id;
                let isOffline = site.properties.isOffline; 

                try {
                    const response = await fetch(`https://api.weather.gov/radar/stations/${radarId}`);
                    if (!response.ok) throw new Error(`Failed to fetch status for ${radarId}`);
                    const data = await response.json();
                    
                    const levelTwoTimeStr = data.properties.latency?.levelTwoLastReceivedTime;
                    let newIsOffline = false;

                    if (levelTwoTimeStr) {
                        const levelTwoTime = new Date(levelTwoTimeStr).getTime();
                        if (levelTwoTime < twentyMinutesAgo) {
                            newIsOffline = true;
                        }
                    } else {
                        newIsOffline = true;
                    }

                    if (isOffline !== newIsOffline) {
                        updatedRadarSitesData[i] = {
                            ...site,
                            properties: {
                                ...site.properties,
                                isOffline: newIsOffline
                            }
                        };
                        changedStatus = true;
                    }

                } catch (error) {
                    console.error(`Error checking status for radar ${radarId}:`, error);
                    if (!isOffline) {
                        updatedRadarSitesData[i] = {
                            ...site,
                            properties: {
                                ...site.properties,
                                isOffline: true
                            }
                        };
                        changedStatus = true;
                    }
                }
            }

            allRadarSitesData = updatedRadarSitesData; 
            
            if (changedStatus && map.getSource('radar-sites')) {
                map.getSource('radar-sites').setData({
                    type: 'FeatureCollection',
                    features: allRadarSitesData
                });
                console.log("Radar statuses updated on map.");
            } else if (!changedStatus) {
                console.log("No radar status changes detected.");
            }
        }


        function updateRadar() { if (map.getSource('weather-radar')) map.getSource('weather-radar').setTiles([ `https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?service=WMS&version=1.1.1&request=GetMap&layers=nexrad-n0q-900913&srs=EPSG:900913&width=256&height=256&format=image/png&transparent=true&bbox={bbox-epsg-3857}&_=${new Date().getTime()}` ]); }
        function updateSingleSiteRadar() { if (map.getSource('single-site-radar-source') && activeSiteIdForData && activeRadarProductCode) { const source = map.getSource('single-site-radar-source'); const tileUrl = `https://opengeo.ncep.noaa.gov/geoserver/${activeSiteIdForData}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${activeSiteIdForData}_${activeRadarProductCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`; source.setTiles([tileUrl]); } }
        async function updateSpcOutlooks() { for (const sourceInfo of spcSources) { const source = map.getSource(sourceInfo.id); if (source) { try { const response = await fetch(`${sourceInfo.url}?t=${new Date().getTime()}`); if (!response.ok) throw new Error(`SPC fetch error for ${sourceInfo.id}`); const geojsonData = await response.json(); source.setData(geojsonData); } catch (error) { console.error(`Failed to refresh SPC outlook for ${sourceInfo.id}:`, error); } } } }

        async function setupMapData() {
            if (map.getSource('weather-radar')) return;

            try {
                const response = await fetch('https://raw.githubusercontent.com/12treesarecool34/treewarn/main/counties-simplified.json');
                const allCountiesGeoJSON = await response.json();
                allCountiesGeoJSON.features.forEach(county => {
                    countyDataMap.set(county.properties.FIPS, county);
                });
                console.log("County geometry data loaded successfully.");
            } catch (error) {
                console.error("Fatal Error: Could not load county geometry data.", error);
                return; 
            }
            
            let firstSymbolId;
            for (const layer of map.getStyle().layers) { if (layer.type === 'symbol') { firstSymbolId = layer.id; break; } }
            
            spcSources.forEach(source => map.addSource(source.id, { type: 'geojson', data: source.url }));
            map.addSource('weather-radar', { 'type': 'raster', 'tiles': [`https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?service=WMS&version=1.1.1&request=GetMap&layers=nexrad-n0q-900913&srs=EPSG:900913&width=256&height=256&format=image/png&transparent=true&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`], 'tileSize': 256 });
            map.addSource('alerts', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            
            const radarSitesResponse = await fetch('https://api.weather.gov/radar/stations?stationType=WSR-88D,TDWR');
            const radarSitesData = await radarSitesResponse.json();
            allRadarSitesData = radarSitesData.features.map(feature => ({
                ...feature,
                properties: {
                    ...feature.properties,
                    isOffline: false 
                }
            }));
            map.addSource('radar-sites', { type: 'geojson', data: { type: 'FeatureCollection', features: allRadarSitesData } });

            const alertColorExpression = ['match', ['get', 'specificEventName']];
            for (const name in alertColorMap) {
                alertColorExpression.push(name, alertColorMap[name]);
            }
            alertColorExpression.push('#808080'); 

            map.addLayer({ id: layerIds.alertsZone, type: 'fill', source: 'alerts', paint: { 'fill-color': alertColorExpression, 'fill-opacity': 0.1 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'zone'] }, firstSymbolId);
            map.addLayer({ id: layerIds.alertsZoneBorder, type: 'line', source: 'alerts', paint: { 'line-color': alertColorExpression, 'line-width': 1 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'zone'] }, firstSymbolId);
            map.addLayer({ id: layerIds.alertsPolygon, type: 'fill', source: 'alerts', paint: { 'fill-color': alertColorExpression, 'fill-opacity': 0.3 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'polygon'] }, firstSymbolId);
            map.addLayer({ id: layerIds.alertsPolygonBorder, type: 'line', source: 'alerts', paint: { 'line-color': alertColorExpression, 'line-width': 2 }, layout: { 'visibility': document.getElementById('alerts-toggle').checked ? 'visible' : 'none' }, filter: ['==', 'geometryType', 'polygon'] }, firstSymbolId);
            
            map.addLayer({ id: layerIds.radar, type: 'raster', source: 'weather-radar', layout: { 'visibility': document.getElementById('radar-toggle').checked ? 'visible' : 'none' } }, layerIds.alertsZone); 
            spcSources.forEach(source => {
                map.addLayer({ id: source.id, type: 'fill', source: source.id, paint: { 'fill-color': ['get', 'fill'], 'fill-opacity': 0.3 }, layout: { 'visibility': 'none' } }, layerIds.radar); 
                map.addLayer({ id: `${source.id}-border`, type: 'line', source: source.id, paint: { 'line-color': ['get', 'fill'], 'line-width': 2 }, layout: { 'visibility': 'none' } }, layerIds.radar); 
            });
            map.addLayer({ 
                id: layerIds.radarSites, 
                type: 'circle', 
                source: 'radar-sites', 
                paint: { 
                    'circle-radius': 4, 
                    'circle-stroke-color': 'white', 
                    'circle-stroke-width': 1.5, 
                    'circle-color': [
                        'case',
                        ['==', ['get', 'isOffline'], true], '#ff0000', 
                        ['==', ['get', 'stationType'], 'WSR-88D'], '#0099ff',
                        ['==', ['get', 'stationType'], 'TDWR'], '#ff9900',
                        '#808080' 
                    ]
                }, 
                layout: { 'visibility': document.getElementById('radar-sites-toggle').checked ? 'visible' : 'none' } 
            });
        }
        
        function updateSpcLayerVisibility() { 
            if (!map.isStyleLoaded()) return; 
            
            allSpcLayerIds.forEach(id => { 
                if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none'); 
            }); 
            
            if (activeSpcDay !== 'none') { 
                const layerToShow = layerIds.spc['day' + activeSpcDay][activeSpcType]; 
                if (layerToShow) { 
                    if (map.getLayer(layerToShow)) map.setLayoutProperty(layerToShow, 'visibility', 'visible'); 
                    if (map.getLayer(`${layerToShow}-border`)) map.setLayoutProperty(`${layerToShow}-border`, 'visibility', 'visible'); 
                }
            }
        }
        
        async function geocodeAndPlaceMarker() { const urlParams = new URLSearchParams(window.location.search); const locationParam = urlParams.get('l'); if (!locationParam) return; const formattedLocation = locationParam.replace(/-/g, ' '); const apiUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(formattedLocation)}&format=json&limit=1`; try { const response = await fetch(apiUrl, { headers: { 'User-Agent': 'TreeRadar-WebApp' } }); const data = await response.json(); if (data && data.length > 0) { const location = data[0]; const lon = parseFloat(location.lon); const lat = parseFloat(location.lat); new maplibregl.Marker({ color: "#FFC300", scale: 0.6 }).setLngLat([lon, lat]).addTo(map); map.flyTo({ center: [lon, lat], zoom: 9, essential: true }); } else { console.warn(`Could not find a location for: ${formattedLocation}`); } } catch (error) { console.error('Geocoding request failed:', error); } }

        const contextMenu = document.getElementById('context-menu');
        const contextMenuUl = contextMenu.querySelector('ul');
        const mainMenuHTML = contextMenuUl.innerHTML;
        let menuHistory = [];

        function showContextMenu(event) {
            event.preventDefault();

            contextMenuUl.innerHTML = mainMenuHTML;
            menuHistory = [];

            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;

            let x = event.clientX;
            let y = event.clientY;

            if (x + menuWidth > viewWidth) x = viewWidth - menuWidth;
            if (y + menuHeight > viewHeight) y = viewHeight - menuHeight;
            x = Math.max(0, x);
            y = Math.max(0, y);


            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';
        }

        function hideContextMenu() {
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                contextMenuUl.innerHTML = mainMenuHTML;
                menuHistory = [];
            }
        }

        // Function to create and show the new Radar Site Popup
        function showRadarSiteMapPopup(site, coordinates) {
            closeAllPopups(); 

            const popupDiv = document.createElement('div');
            popupDiv.className = 'map-popup-base map-radar-popup-accent'; 

            const props = site.properties;
            const clickedStationId = props.id;
            const clickedStationIdLower = clickedStationId.toLowerCase();
            const name = props.name;
            const stationType = props.stationType;
            const isOffline = props.isOffline; 

            // Determine accent color for the radar popup with 50% transparency
            let accentColorHex = '#808080'; // Default gray
            if (isOffline) {
                accentColorHex = '#ff0000'; // Red if offline
            } else if (stationType === 'WSR-88D') {
                accentColorHex = '#0099ff'; // Blue
            } else if (stationType === 'TDWR') {
                accentColorHex = '#ff9900'; // Orange
            }
            popupDiv.style.borderTop = `5px solid ${hexToRgba(accentColorHex, 0.5)}`;

            let buttonsHtml = '';
            if (stationType === 'TDWR') {
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'brefl')">Long Range Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'bref1')">Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'bvel')">Velocity</button></li>`;
            } else { // WSR-88D
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'sr_bref')">Reflectivity</button></li>`;
                buttonsHtml += `<li><button onclick="toggleRadarProduct('${clickedStationIdLower}', 'sr_bvel')">Velocity</button></li>`;
            }

            popupDiv.innerHTML = `
                <h4>${clickedStationId} - ${name}</h4>
                <div class="popup-content-area">
                    <ul>
                        ${buttonsHtml}
                    </ul>
                </div>
            `;

            currentMapPopup = new maplibregl.Popup({
                closeOnClick: true, 
                closeButton: false, /* Removed X button */
                anchor: 'bottom', 
                className: 'custom-map-popup-container' 
            })
            .setLngLat(coordinates)
            .setDOMContent(popupDiv)
            .addTo(map);

            currentMapPopup._container.addEventListener('contextmenu', disableContextMenu);
        }

        // Function to create and show the new Alert Popup
        function showAlertMapPopup(features, clickedLngLat) {
            closeAllPopups(); 
            
            currentStackedAlertsOnMap = features;
            currentStackedAlertIndex = 0;

            const popupDiv = document.createElement('div');
            popupDiv.className = 'map-popup-base map-alert-popup-accent-top'; 

            const updatePopupContent = () => {
                const feature = currentStackedAlertsOnMap[currentStackedAlertIndex];
                if (!feature) {
                    closeAllPopups();
                    return;
                }

                const props = feature.properties;
                const params = props.parameters || {};
                const alertTitle = props.specificEventName || props.event || "Weather Alert";
                
                // Get the specific alert color for the top border accent
                const accentColor = alertColorMap[alertTitle] || '#808080';
                popupDiv.style.borderTop = `5px solid ${hexToRgba(accentColor, 0.5)}`;

                let tagsHtml = '';

                // Add Expires to the map popup tags
                const expireDate = parseApiDate(props.expires);
                if (expireDate && !isNaN(expireDate.getTime())) {
                    const dateOptions = { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
                    const expireString = expireDate.toLocaleString('en-US', dateOptions);
                    tagsHtml += `<p><strong>Expires:</strong> ${expireString}</p>`;
                }

                const tornado = params.tornadoDetection ? params.tornadoDetection[0] : null;
                if (tornado && formatThreatValue(tornado)) { tagsHtml += `<p><strong>Tornado:</strong> ${formatThreatValue(tornado)}</p>`; }
                const waterspout = params.waterspoutDetection ? params.waterspoutDetection[0] : null;
                if (waterspout && formatThreatValue(waterspout)) { tagsHtml += `<p><strong>Waterspout:</strong> ${formatThreatValue(waterspout)}</p>`; }
                const torDamage = params.tornadoDamageThreat ? params.tornadoDamageThreat[0] : null;
                const tstDamage = params.thunderstormDamageThreat ? params.thunderstormDamageThreat[0] : null;
                const fldDamage = params.flashFloodDamageThreat ? params.flashFloodDamageThreat[0] : null;
                const damageThreat = torDamage || tstDamage || fldDamage;
                if (damageThreat && formatThreatValue(damageThreat)) { tagsHtml += `<p><strong>Threat:</strong> ${formatThreatValue(damageThreat)}</p>`; }
                const windGust = params.maxWindGust ? params.maxWindGust[0] : null;
                if (windGust && windGust !== '0 MPH' && formatThreatValue(windGust)) {
                    const windThreat = params.windThreat ? params.windThreat[0] : null;
                    let windText = windGust.replace("MPH", "mph");
                    if (windThreat && formatThreatValue(windThreat)) { windText += `, ${formatThreatValue(windThreat)}`; }
                    tagsHtml += `<p><strong>Winds:</strong> ${windText}</p>`;
                }
                const hailSize = params.maxHailSize ? params.maxHailSize[0] : null;
                if (hailSize && hailSize !== '0.00' && formatThreatValue(hailSize)) {
                    const hailThreat = params.hailThreat ? params.hailThreat[0] : null;
                    let hailText = hailSize + '"';
                    if (hailThreat && formatThreatValue(hailThreat)) { hailText += `, ${formatThreatValue(hailThreat)}`; }
                    tagsHtml += `<p><strong>Hail:</strong> ${hailText}</p>`;
                }
                const flashFloodDetection = params.flashFloodDetection ? params.flashFloodDetection[0] : null;
                if (flashFloodDetection && formatThreatValue(flashFloodDetection)) { tagsHtml += `<p><strong>Source:</strong> ${formatThreatValue(flashFloodDetection)}</p>`; }


                let pagerHtml = '';
                if (currentStackedAlertsOnMap.length > 1) {
                    pagerHtml = '<div class="alert-pager">';
                    for (let i = 0; i < currentStackedAlertsOnMap.length; i++) {
                        pagerHtml += `<div class="pager-dot ${i === currentStackedAlertIndex ? 'active' : ''}" data-index="${i}"></div>`;
                    }
                    pagerHtml += '</div>';
                }

                popupDiv.innerHTML = `
                    <h4>${alertTitle}</h4>
                    <div class="popup-content-area">
                        ${tagsHtml}
                        <ul>
                            <li><button id="full-text-button">Full Text</button></li>
                        </ul>
                    </div>
                    ${pagerHtml}
                `;

                popupDiv.querySelector('#full-text-button').addEventListener('click', () => {
                    showFullAlertTextPopup(feature);
                });

                if (currentStackedAlertsOnMap.length > 1) {
                    popupDiv.querySelectorAll('.pager-dot').forEach(dot => {
                        dot.addEventListener('click', (e) => {
                            currentStackedAlertIndex = parseInt(e.target.dataset.index, 10);
                            updatePopupContent(); 
                        });
                    });
                }
            };
            
            updatePopupContent(); 

            currentMapPopup = new maplibregl.Popup({
                closeOnClick: true,
                closeButton: false, /* Removed X button */
                anchor: 'bottom',
                className: 'custom-map-popup-container'
            })
            .setLngLat(clickedLngLat)
            .setDOMContent(popupDiv)
            .addTo(map);

            currentMapPopup._container.addEventListener('contextmenu', disableContextMenu);
        }

        // Function to create and show the Full Alert Text Popup
        function showFullAlertTextPopup(feature) {
            const props = feature.properties;
            const params = props.parameters || {};

            const overlay = document.getElementById('full-alert-text-popup-overlay');
            const contentDiv = document.getElementById('full-alert-text-content');
            const fullAlertPopupElement = document.getElementById('full-alert-text-popup');

            const alertTitle = props.specificEventName || props.event || "Weather Alert";
            
            // Get the specific alert color for the borders of the full text popup
            const accentColor = alertColorMap[alertTitle] || '#808080';
            const rgbaAccentColor = hexToRgba(accentColor, 0.5);
            fullAlertPopupElement.style.borderLeft = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderTop = `5px solid ${rgbaAccentColor}`;
            fullAlertPopupElement.style.borderRight = `5px solid ${rgbaAccentColor}`;


            const issuedDate = parseApiDate(props.sent);
            const expireDate = parseApiDate(props.expires);
            const dateOptions = { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
            const issuedString = issuedDate && !isNaN(issuedDate.getTime()) ? issuedDate.toLocaleString('en-US', dateOptions) : ""; 
            const expireString = expireDate && !isNaN(expireDate.getTime()) ? expireDate.toLocaleString('en-US', dateOptions) : ""; 

            let fullHtml = `<h4>${alertTitle}</h4>`;
            
            let hasDateAffected = false;
            if (issuedString) { fullHtml += `<p><strong>Sent:</strong> ${issuedString}</p>`; hasDateAffected = true; }
            if (expireString) { fullHtml += `<p><strong>Expires:</strong> ${expireString}</p>`; hasDateAffected = true; }
            if (props.areaDesc && props.areaDesc.toUpperCase() !== 'N/A') {
                fullHtml += `<p><strong>Affected:</strong> ${props.areaDesc}</p>`; hasDateAffected = true;
            }
            if (hasDateAffected) { fullHtml += `<p>&nbsp;</p>`; } 

            let tagsHtmlContent = '';
            const tornado = params.tornadoDetection ? params.tornadoDetection[0] : null;
            if (tornado && formatThreatValue(tornado)) { tagsHtmlContent += `<p><strong>Tornado:</strong> ${formatThreatValue(tornado)}</p>`; }
            const waterspout = params.waterspoutDetection ? params.waterspoutDetection[0] : null;
            if (waterspout && formatThreatValue(waterspout)) { tagsHtmlContent += `<p><strong>Waterspout:</strong> ${formatThreatValue(waterspout)}</p>`; }
            const torDamage = params.tornadoDamageThreat ? params.tornadoDamageThreat[0] : null;
            const tstDamage = params.thunderstormDamageThreat ? params.thunderstormDamageThreat[0] : null;
            const fldDamage = params.flashFloodDamageThreat ? params.flashFloodDamageThreat[0] : null;
            const damageThreat = torDamage || tstDamage || fldDamage;
            if (damageThreat && formatThreatValue(damageThreat)) { tagsHtmlContent += `<p><strong>Threat:</strong> ${formatThreatValue(damageThreat)}</p>`; }
            const windGust = params.maxWindGust ? params.maxWindGust[0] : null;
            if (windGust && windGust !== '0 MPH' && formatThreatValue(windGust)) {
                const windThreat = params.windThreat ? params.windThreat[0] : null;
                let windText = windGust.replace("MPH", "mph");
                if (windThreat && formatThreatValue(windThreat)) { windText += `, ${formatThreatValue(windThreat)}`; }
                tagsHtmlContent += `<p><strong>Winds:</strong> ${windText}</p>`;
            }
            const hailSize = params.maxHailSize ? params.maxHailSize[0] : null;
            if (hailSize && hailSize !== '0.00' && formatThreatValue(hailSize)) {
                const hailThreat = params.hailThreat ? params.hailThreat[0] : null;
                let hailText = hailSize + '"';
                if (hailThreat && formatThreatValue(hailThreat)) { hailText += `, ${formatThreatValue(hailThreat)}`; }
                tagsHtmlContent += `<p><strong>Hail:</strong> ${hailText}</p>`;
            }
            const flashFloodDetection = params.flashFloodDetection ? params.flashFloodDetection[0] : null;
            if (flashFloodDetection && formatThreatValue(flashFloodDetection)) { tagsHtmlContent += `<p><strong>Source:</strong> ${formatThreatValue(flashFloodDetection)}</p>`; }
            
            if (tagsHtmlContent) {
                fullHtml += tagsHtmlContent + `<p>&nbsp;</p>`; 
            }

            let descriptionText = (props.description || "").replace(/\n/g, '<br>').trim();
            if (descriptionText) {
                fullHtml += `<p><strong>Description:</strong></p><p>${descriptionText}</p>`;
            }
            
            let instructionText = (props.instruction || "").replace(/\n/g, '<br>').trim();
            if (instructionText && instructionText.toUpperCase() !== 'N/A') {
                fullHtml += `<p>&nbsp;</p><p><strong>Instructions:</strong></p><p>${instructionText}</p>`;
            }

            contentDiv.innerHTML = fullHtml;
            overlay.style.display = 'flex'; 
        }

        document.addEventListener('contextmenu', showContextMenu);
        document.addEventListener('click', hideContextMenu);
        
        map.on('load', async () => {
            await setupMapData();
            updateSpcLayerVisibility();
            geocodeAndPlaceMarker(); 
            
            checkRadarStatus();
            setInterval(checkRadarStatus, 300000);

            contextMenuUl.addEventListener('click', (e) => {
                const targetLi = e.target.closest('li');
                if (!targetLi) return;

                e.stopPropagation();

                if (targetLi.id === 'context-menu-back') {
                    const previousMenuHTML = menuHistory.pop();
                    if (previousMenuHTML) {
                        contextMenuUl.innerHTML = previousMenuHTML;
                    }
                    return;
                }

                const submenu = targetLi.querySelector('.context-submenu');
                if (submenu) {
                    menuHistory.push(contextMenuUl.innerHTML);
                    const submenuUl = submenu.querySelector('ul');
                    if (submenuUl) {
                        contextMenuUl.innerHTML = `<li id="context-menu-back"><div class="menu-item-text"><i class="material-symbols-rounded">arrow_back</i>Back</div></li>` + submenuUl.innerHTML;
                    }
                    return;
                }

                if (targetLi.classList.contains('outlook-type')) {
                    activeSpcDay = targetLi.dataset.day;
                    activeSpcType = targetLi.dataset.type;
                    updateSpcLayerVisibility();
                    hideContextMenu();
                }

                switch (targetLi.id) {
                    case 'context-menu-mosaic':
                        const radarToggle = document.getElementById('radar-toggle');
                        radarToggle.checked = !radarToggle.checked;
                        updateMosaicVisibility();
                        hideContextMenu();
                        break;
                    case 'context-menu-alerts':
                        const alertsToggle = document.getElementById('alerts-toggle');
                        const newState = !alertsToggle.checked;
                        alertsToggle.checked = newState;
                        const v = newState ? 'visible' : 'none';
                        const alertLayers = [layerIds.alertsZone, layerIds.alertsZoneBorder, layerIds.alertsPolygon, layerIds.alertsPolygonBorder];
                        alertLayers.forEach(layerId => {
                            if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', v);
                        });
                        hideContextMenu();
                        break;
                    case 'context-menu-sites':
                        const sitesToggle = document.getElementById('radar-sites-toggle');
                        sitesToggle.checked = !sitesToggle.checked;
                        if (map.getLayer(layerIds.radarSites)) map.setLayoutProperty(layerIds.radarSites, 'visibility', sitesToggle.checked ? 'visible' : 'none');
                        hideContextMenu();
                        break;
                }
            });
            
            updateAlerts();

            setInterval(updateAlerts, 60000); 
            setInterval(updateRadar, 60000); 
            setInterval(updateSingleSiteRadar, 45000);
            setInterval(updateSpcOutlooks, 600000);

            map.on('mouseup', (e) => {
                if (e.originalEvent.button !== 1) { // Not a middle click
                    return;
                }
                
                e.preventDefault();
                closeAllPopups(); // Close any open popups

                if (!allRadarSitesData || allRadarSitesData.length === 0) return;

                // Find the nearest radar site
                let nearestSite = null;
                let minDistance = Infinity;
                const clickPoint = e.lngLat;
                allRadarSitesData.forEach(site => {
                    if (site.geometry && site.geometry.coordinates) {
                        const sitePoint = new maplibregl.LngLat(site.geometry.coordinates[0], site.geometry.coordinates[1]);
                        const distance = clickPoint.distanceTo(sitePoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestSite = site;
                        }
                    }
                });

                if (nearestSite) {
                    const targetSiteType = nearestSite.properties.stationType;
                    const targetSiteId = nearestSite.properties.id.toLowerCase();
                    const coordinates = nearestSite.geometry.coordinates.slice();

                    let targetProduct = null;

                    // Determine current mode
                    const isMosaicMode = !activeSiteIdForData;
                    const currentProduct = activeRadarProductCode;
                    
                    if (isMosaicMode) { // Mosaic > Reflectivity
                        targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                    } else {
                        // Current mode is single-site
                        switch (currentProduct) {
                            case 'sr_bvel': // Velocity -> Velocity
                            case 'bvel':
                                targetProduct = (targetSiteType === 'TDWR') ? 'bvel' : 'sr_bvel';
                                break;
                            
                            case 'sr_bref': // Reflectivity -> Reflectivity
                            case 'bref1':
                                targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                                break;

                            case 'brefl': // Long Range -> Reflectivity:WSR-88D, Long Range:TDWR
                                targetProduct = (targetSiteType === 'TDWR') ? 'brefl' : 'sr_bref';
                                break;
                            
                            default: // Fallback to reflectivity
                                targetProduct = (targetSiteType === 'TDWR') ? 'bref1' : 'sr_bref';
                                break;
                        }
                    }

                    // Fly to the site and toggle the product
                    map.flyTo({ center: coordinates, zoom: 7.5, speed: 1.5, curve: 1.4, essential: true });
                    
                    // Only toggle if we have a valid product and it's a new site or a new product
                    if (targetProduct && (activeSiteIdForData !== targetSiteId || activeRadarProductCode !== targetProduct)) {
                         toggleRadarProduct(targetSiteId, targetProduct);
                    }
                }
            });
        });

        map.on('style.load', async () => {
            await setupMapData();
            updateSpcLayerVisibility();
            geocodeAndPlaceMarker();
            checkRadarStatus();
        });
        
        map.on('click', (e) => {
            const clickableLayers = [layerIds.radarSites, layerIds.alertsZone, layerIds.alertsPolygon]; 
            const features = map.queryRenderedFeatures(e.point, { layers: clickableLayers });
            closeAllPopups(); 
            if (!features.length) return;
            const topFeature = features[0];
            const props = topFeature.properties;

            if (topFeature.layer.id === layerIds.radarSites) {
                const clickedStationId = props.id;
                const nearestSite = allRadarSitesData.find(site => site.properties.id === clickedStationId);
                if (nearestSite) {
                    if (activeSiteIdForMenu === clickedStationId) { closeAllPopups(); return; }
                    const clickedStationIdLower = clickedStationId.toLowerCase();
                    if (activeSiteIdForData && activeSiteIdForData !== clickedStationIdLower) { removeSingleSiteLayer(); activeRadarProductCode = null; activeSiteIdForData = null; }
                    activeSiteIdForMenu = clickedStationId;
                    const coordinates = topFeature.geometry.coordinates.slice();
                    map.flyTo({ center: coordinates, zoom: 7.5, speed: 1.5, curve: 1.4, essential: true });
                    map.once('moveend', () => {
                        if (activeSiteIdForMenu !== clickedStationId) return;
                        showRadarSiteMapPopup(nearestSite, coordinates); 
                    });
                }
            } else if (topFeature.layer.id === layerIds.alertsZone || topFeature.layer.id === layerIds.alertsPolygon) { 
                const alertsAtClickPoint = map.queryRenderedFeatures(e.point, { layers: [layerIds.alertsZone, layerIds.alertsPolygon] })
                                            .map(f => allActiveAlerts.find(alert => alert.properties.id === f.properties.id))
                                            .filter(Boolean); 

                if (alertsAtClickPoint.length > 0) {
                    showAlertMapPopup(alertsAtClickPoint, e.lngLat);
                }
            }
        });

        const alertHoverLayers = [layerIds.alertsZone, layerIds.alertsPolygon];
        map.on('mouseenter', alertHoverLayers, () => { map.getCanvas().style.cursor = 'pointer'; });
        map.on('mouseleave', alertHoverLayers, () => { map.getCanvas().style.cursor = ''; });
        map.on('mouseenter', layerIds.radarSites, () => { map.getCanvas().style.cursor = 'pointer'; });
        map.on('mouseleave', layerIds.radarSites, () => { map.getCanvas().style.cursor = ''; });

        document.addEventListener('keydown', (event) => {
            if (!event.shiftKey || !activeSiteIdForData) {
                return; // Only proceed if Shift is held and a single site is active
            }

            const siteData = allRadarSitesData.find(site => site.properties.id.toLowerCase() === activeSiteIdForData);
            if (!siteData) return;

            const stationType = siteData.properties.stationType;
            let newProduct = null;

            switch (event.key.toUpperCase()) {
                case 'R':
                    event.preventDefault();
                    newProduct = (stationType === 'TDWR') ? 'bref1' : 'sr_bref';
                    break;
                case 'V':
                    event.preventDefault();
                    newProduct = (stationType === 'TDWR') ? 'bvel' : 'sr_bvel';
                    break;
                case 'L':
                    if (stationType === 'TDWR') {
                        event.preventDefault();
                        newProduct = 'brefl';
                    }
                    break;
            }

            if (newProduct && newProduct !== activeRadarProductCode) {
                toggleRadarProduct(activeSiteIdForData, newProduct);
            }
        });

    </script>
</body>
</html>
