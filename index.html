<!DOCTYPE html>
<html lang="en">

<head>
    <title>TreeWarn</title>
    <link rel="icon" href="https://raw.githubusercontent.com/microsoft/fluentui-emoji/refs/heads/main/assets/Deciduous%20tree/3D/deciduous_tree_3d.png" />

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.6/turf.min.js"></script>

    <link href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@maplibre/maplibre-gl-leaflet@0.0.21/leaflet-maplibre-gl.js"></script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">

    <style>
        * {
            font-family: 'Outfit', sans-serif;
        }
        body {
            overflow: hidden;
            margin: 0;
        }
        #map-container {
            z-index: 1;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0px;
            left: 0px;
        }
        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            width: max-content;
            overflow: hidden;
            color: white;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
        }
        .context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .context-menu ul li {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
        }
        .context-menu .material-symbols-outlined {
            padding-right: 10px;
        }
        .context-menu ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        button {
            padding: 4px;
            margin: 8px;
            background: rgb(254, 22, 103);
            color: black;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-size: large;
            width: 100px;
        }
        button:hover {
            background: rgb(255, 80, 120);
        }
        select {
            padding: 5px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: large;
        }
        .text-overlay {
            position: absolute;
            right: 0px;
            z-index: 1001;
            padding: 5px;
            margin: 10px;
            color: white;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
            width: fit-content;
            height: fit-content;
            max-height: calc(100vh - 30px);
            overflow: hidden;
        }
        .text-overlay h2,
        .text-overlay p {
            border-radius: 10px;
            padding: 10px;
            margin: 5px;
            border: none;
            white-space: pre-wrap;
            overflow: hidden;
        }
        .text-overlay h2:hover,
        .text-overlay p:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .text-overlay h2:focus,
        .text-overlay p:focus {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            outline: none;
        }
        .text-overlay .no-edit:hover {
            background-color: transparent;
            cursor: default;
        }
    </style>
</head>

<body>
    <div id="content">
        <div id="map-container"></div>

        <div class="text-overlay" id="text-overlay">
            <h2 contenteditable="true" spellcheck="false">Alert Title</h2>
            <p contenteditable="true" spellcheck="false">Alert Text</p>
        </div>

        <div id="loader-overlay" style="z-index: 100; flex-direction: column; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; color: white; display: flex; align-items: center; justify-content: center;">
            <h2>Loading...</h2>
        </div>

        <div id="settings-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>Settings</h1>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="theme-toggle-checkbox" onchange="toggleMapTheme();" type="checkbox"> Use light maps
                </div>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="radar-toggle-checkbox" onchange="toggleRadarLayer(this);" type="checkbox" checked> Radar
                </div>
                <h3>Styles</h3>
                <div style="display: flex; flex-direction: column; align-items: left;">
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Color: </p>
                        <select id="color-preset-select" style="min-width: 150px;">
                            <option value="custom">Custom</option>
                            <option value="#FF0000">Tornado</option>
                            <option value="#FFA500">Severe</option>
                            <option value="#ADD8E6">Statement</option>
                            <option value="#FFFF00">Tropical</option>
                            <option value="#008080">Flash Flood</option>
                            <option value="#008000">Flood</option>
                            <option value="#8B0000">Tornado Watch</option>
                            <option value="#556B2F">Severe Watch</option>
                            <option value="#0000FF">Discussion</option>
                        </select>
                    </div>
                    <div id="custom-color-picker-container" style="display: flex; flex-direction: row; align-items: center; margin-top: 10px;">
                        <p style="margin: 0px 10px 0px 0px;">Custom Color: </p>
                        <input id="custom-color-input" type="color" value="#000000">
                    </div>
                    <br>
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Level: </p>
                        <select id="level-preset-select" style="min-width: 150px;">
                            <option value="standard">Standard</option>
                            <option value="considerable">Considerable</option>
                            <option value="destructive">Destructive</option>
                            <option value="pds">Particularly Dangerous</option>
                            <option value="emergency">Emergency</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                        <button id="close-settings-button">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="share-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>Share</h1>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="share-settings-checkbox" onchange="updateShareUrl()" type="checkbox"> Share settings
                </div>
                <h3>Copy this URL modifier to share your alerts!</h3>
                <input type="text" id="share-url-input" style="width: 250px;">
                <div style="display: flex; flex-direction: column; align-items: left;">
                    <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                        <button id="close-share-button">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="about-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>About TreeWarn</h1>
                <p>TreeWarn is a simple tool for creating and visualizing your own weather alerts.</p>
                <p>This is a modified version of <a href="https://busybird15.github.io/sparkgen">SparkGen</a>, which was made by <a href="https://busybird15.github.io/">BusyBird15</a>.</p>
                <p>Radar data is from the <a href="https://mesonet.agron.iastate.edu/">Iowa Environmental Mesonet</a>.</p>
                <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                    <button id="close-about-button">Close</button>
                </div>
            </div>
        </div>

        <div id="context-menu" class="context-menu">
            <ul>
                <li id="context-menu-new-polygon"><i class="material-symbols-outlined">add</i>New Polygon</li>
                <li id="context-menu-new-marker"><i class="material-symbols-outlined">add_location</i>New Marker</li>
                <li id="context-menu-settings"><i class="material-symbols-outlined">settings</i>Settings</li>
                <li id="context-menu-about"><i class="material-symbols-outlined">info</i>About</li>
                <li id="context-menu-edit"><i class="material-symbols-outlined">edit</i>Edit</li>
                <li id="context-menu-delete"><i class="material-symbols-outlined">delete</i>Delete</li>
                <li id="context-menu-share"><i class="material-symbols-outlined">share</i>Share</li>
            </ul>
        </div>

        <div id="viewport-sizer" style="font-size: larger; z-index: 1000; justify-content: center; flex-direction: row; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none; align-items: center;">
            200x200
        </div>
    </div>

    <script>
        const map = L.map(document.getElementById("map-container"), {
            preferCanvas: true,
            doubleClickZoom: false,
            attributionControl: true,
            zoomControl: false,
            zoomSnap: 0,
            minZoom: 2
        }).setView([38.0, -100.4], 4);

        const southWest = L.latLng(-85, -180);
        const northEast = L.latLng(85, 180);
        const bounds = L.latLngBounds(southWest, northEast);
        map.setMaxBounds(bounds);
        map.on('drag', function() {
            map.panInsideBounds(bounds, { animate: false });
        });

        map.createPane('radar');
        map.getPane('radar').style.zIndex = 250;
        map.createPane('cities');
        map.getPane('cities').style.zIndex = 400;
        map.createPane('dashedLines');
        map.getPane('dashedLines').style.zIndex = 399;
        map.createPane('warnings');
        map.getPane('warnings').style.zIndex = 398;
        map.createPane('counties');
        map.getPane('counties').style.zIndex = 301;

        const emergencyDashesGroup = new L.FeatureGroup([], { pane: 'dashedLines' }).addTo(map);
        const warningPolygonsLayer = L.featureGroup([], { pane: 'warnings' }).addTo(map);
        const customMarkersLayer = L.featureGroup([], { pane: 'counties' }).addTo(map);
        const warningMarkersLayer = L.featureGroup([], { pane: 'warnings' }).addTo(map);
        let countyBoundariesLayer = L.geoJSON().addTo(map);
        
        L.drawLocal.draw.handlers.polygon.tooltip.start = null;
        L.drawLocal.draw.handlers.polygon.tooltip.cont = null;
        L.drawLocal.draw.handlers.polygon.tooltip.end = null;
        L.drawLocal.draw.handlers.marker.tooltip.start = null;
        L.drawLocal.edit.handlers.edit.tooltip.text = null;
        L.drawLocal.edit.handlers.edit.tooltip.subtext = null;
        L.drawLocal.edit.handlers.remove.tooltip.text = null;
        
        const lightThemeLayer = L.maplibreGL({
            style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        });
        const darkThemeLayer = L.maplibreGL({
            style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        }).addTo(map);
        let currentThemeLayer = darkThemeLayer;

        const radarLayer = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
            layers: 'nexrad-n0r-900913',
            format: 'image/png',
            transparent: true,
            pane: 'radar',
            attribution: "IEM"
        }).addTo(map);

        setInterval(() => {
            if (map.hasLayer(radarLayer)) {
                radarLayer.setParams({ time: Date.now() });
            }
        }, 60000);

        function toggleMapTheme() {
            if (currentThemeLayer) {
                map.removeLayer(currentThemeLayer);
            }
            currentThemeLayer = (currentThemeLayer === lightThemeLayer) ? darkThemeLayer : lightThemeLayer;
            map.addLayer(currentThemeLayer);
        }
        
        function toggleRadarLayer(checkbox) {
            if (checkbox.checked) {
                map.addLayer(radarLayer);
            } else {
                map.removeLayer(radarLayer);
            }
        }

        let activeColor = '#000000';
        let activeOpacity = 0.3;
        let isDrawing = false;
        let selectedPolygon = null;
        let selectedMarker = null;
        let isSharedMode = false;

        function reverseSubarrays(arr) {
            return arr.map(subArr => subArr.slice().reverse());
        }

        function styleCountyFeature(feature, layer) {
            layer.setStyle({
                color: 'black',
                fillOpacity: 0,
                weight: 0
            });
            layer.customColor = 'no';
        }

        fetch('https://raw.githubusercontent.com/12treesarecool34/treewarn/refs/heads/main/counties-simplified.json')
            .then(response => response.json())
            .then(data => {
                countyBoundariesLayer = L.geoJSON(data, {
                    onEachFeature: styleCountyFeature,
                    pane: 'counties'
                }).addTo(map);
                loadDataFromUrl();
                document.getElementById("loader-overlay").style.display = "none";
            })
            .catch(error => console.error('Error loading GeoJSON data:', error));
        
        let contextMenuX = 0;
        let contextMenuY = 0;

        function showContextMenu(event) {
            event.preventDefault();
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';

            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            contextMenuX = event.clientX;
            contextMenuY = event.clientY;

            if (contextMenuX + menuWidth > windowWidth) contextMenuX = windowWidth - menuWidth;
            if (contextMenuY + menuHeight > windowHeight) contextMenuY = windowHeight - menuHeight;
            if (contextMenuX < 0) contextMenuX = 0;
            if (contextMenuY < 0) contextMenuY = 0;

            menu.style.left = `${contextMenuX}px`;
            menu.style.top = `${contextMenuY}px`;
        }
        document.addEventListener('contextmenu', showContextMenu);

        document.getElementById('context-menu-new-polygon').addEventListener('click', () => {
            isDrawing = true;
            polygonDrawer.enable();
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-new-marker').addEventListener('click', () => {
            isDrawing = true;
            markerDrawer.enable();
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-settings').addEventListener('click', () => {
            document.getElementById('settings-modal').style.display = 'flex';
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-share').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'flex';
            document.getElementById('context-menu').style.display = 'none';
            updateShareUrl();
        });

        document.getElementById('context-menu-about').addEventListener('click', () => {
            document.getElementById('about-modal').style.display = 'flex';
            document.getElementById('context-menu').style.display = 'none';
        });

        const featureGroupForEditing = new L.FeatureGroup().addTo(map);
        let currentEditHandler = null;

        document.getElementById('context-menu-edit').addEventListener('click', () => {
            let layerToEdit = selectedPolygon || selectedMarker;
            if (layerToEdit && (layerToEdit.isCustomPolygon || layerToEdit.isCustomMarker)) {
                if (layerToEdit.isCustomPolygon) {
                   removeEmergencyDash(layerToEdit);
                   if (warningPolygonsLayer.hasLayer(layerToEdit)) warningPolygonsLayer.removeLayer(layerToEdit);
                   else if (countyBoundariesLayer.hasLayer(layerToEdit)) countyBoundariesLayer.removeLayer(layerToEdit);
                } else {
                   if (warningMarkersLayer.hasLayer(layerToEdit)) warningMarkersLayer.removeLayer(layerToEdit);
                   else if (customMarkersLayer.hasLayer(layerToEdit)) customMarkersLayer.removeLayer(layerToEdit);
                }
                featureGroupForEditing.addLayer(layerToEdit);
                currentEditHandler = new L.EditToolbar.Edit(map, { featureGroup: featureGroupForEditing });
                currentEditHandler.enable();
            }
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-delete').addEventListener('click', () => {
            if (selectedPolygon && selectedPolygon.isCustomPolygon) {
                removeEmergencyDash(selectedPolygon);
                if (warningPolygonsLayer.hasLayer(selectedPolygon)) warningPolygonsLayer.removeLayer(selectedPolygon);
                if (countyBoundariesLayer.hasLayer(selectedPolygon)) countyBoundariesLayer.removeLayer(selectedPolygon);
            }
            if (selectedMarker && selectedMarker.isCustomMarker) {
                if (warningMarkersLayer.hasLayer(selectedMarker)) warningMarkersLayer.removeLayer(selectedMarker);
                if (customMarkersLayer.hasLayer(selectedMarker)) customMarkersLayer.removeLayer(selectedMarker);
            }
            document.getElementById('context-menu').style.display = 'none';
        });

        const polygonDrawer = new L.Draw.Polygon(map, {});
        const markerDrawer = new L.Draw.Marker(map, {
            icon: new L.DivIcon({ className: 'leaflet-draw-marker-icon', iconSize: [20, 20] })
        });

        map.on('draw:created', (event) => {
            isDrawing = false;
            const type = event.layerType;
            const layer = event.layer;
            
            if (type === 'polygon') {
                const polygon = L.polygon(reverseSubarrays(layer.toGeoJSON()['geometry']['coordinates'][0]), {
                    color: 'black', pane: 'counties', fillOpacity: 0, weight: 2
                }).addTo(countyBoundariesLayer);
                polygon.customColor = 'no';
                polygon.isCustomPolygon = true;
            } else if (type === 'marker') {
                const marker = L.circleMarker(layer.getLatLng(), {
                    radius: 6, color: 'black', weight: 2, fillColor: 'grey', fillOpacity: 0.5, pane: 'counties'
                }).addTo(customMarkersLayer);
                marker.customColor = 'no';
                marker.isCustomMarker = true;
            }
        });

        map.on('draw:canceled', () => isDrawing = false);
        
        map.on(L.Draw.Event.EDITSTOP, () => {
            const layersToAddBack = [];
            featureGroupForEditing.eachLayer(layer => {
                layersToAddBack.push(layer);
                 if (layer instanceof L.Polygon && layer.customColor === 'yes' && layer.levelPreset === 'emergency') {
                    createEmergencyDash(layer);
                }
            });
            featureGroupForEditing.clearLayers();
            layersToAddBack.forEach(layer => {
                const isWarning = layer.customColor === 'yes';
                const isPolygon = layer instanceof L.Polygon;
                if (isWarning) {
                    if(isPolygon) warningPolygonsLayer.addLayer(layer);
                    else warningMarkersLayer.addLayer(layer);
                } else {
                    if(isPolygon) countyBoundariesLayer.addLayer(layer);
                    else customMarkersLayer.addLayer(layer);
                }
            });
            currentEditHandler = null;
        });

        map.on('contextmenu', (event) => {
            const clickedPoint = event.latlng;
            const clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            let foundPolygon = false;
            let foundMarker = false;
            selectedPolygon = null;
            selectedMarker = null;

            const editMenuItem = document.getElementById('context-menu-edit');
            const deleteMenuItem = document.getElementById('context-menu-delete');

            const checkMarker = (marker) => {
                if (foundMarker) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    foundMarker = true;
                    selectedMarker = marker;
                }
            };

            warningMarkersLayer.eachLayer(checkMarker);
            if (!foundMarker) customMarkersLayer.eachLayer(checkMarker);

            const checkPolygon = (layer) => {
                if (foundPolygon || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    foundPolygon = true;
                    selectedPolygon = layer;
                }
            };
            
            if (!foundMarker) {
                warningPolygonsLayer.getLayers().slice().reverse().forEach(checkPolygon);
                if (!foundPolygon) {
                    countyBoundariesLayer.getLayers().slice().reverse().forEach(checkPolygon);
                }
            }

            const isCustom = (selectedPolygon && selectedPolygon.isCustomPolygon) || (selectedMarker && selectedMarker.isCustomMarker);
            editMenuItem.style.display = isCustom ? 'flex' : 'none';
            deleteMenuItem.style.display = isCustom ? 'flex' : 'none';
        });

        map.on('click', (event) => {
            const contextMenu = document.getElementById('context-menu');
            if (contextMenu.style.display !== 'none') {
                contextMenu.style.display = 'none';
                return;
            }
            if (isSharedMode || isDrawing || currentEditHandler) return;

            const clickedPoint = event.latlng;
            const clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            let handled = false;

            warningMarkersLayer.eachLayer(marker => {
                if (handled) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    handled = true;
                    warningMarkersLayer.removeLayer(marker);
                    marker.setStyle({ radius: 6, color: 'black', weight: 2, fillColor: 'grey', fillOpacity: 0.5 });
                    marker.customColor = 'no';
                    marker.levelPreset = null;
                    marker.baseColor = null;
                    customMarkersLayer.addLayer(marker);
                }
            });
            if(handled) return;

            warningPolygonsLayer.getLayers().slice().reverse().forEach(layer => {
                if (handled || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    handled = true;
                    warningPolygonsLayer.removeLayer(layer);
                    removeEmergencyDash(layer);
                    const newWeight = layer.isCustomPolygon ? 2 : 0;
                    layer.setStyle({ fillOpacity: 0, color: 'black', weight: newWeight });
                    layer.customColor = 'no';
                    layer.levelPreset = null;
                    layer.baseColor = null;
                    delete layer.options.baseWeight;
                    countyBoundariesLayer.addLayer(layer);
                }
            });
            if (handled) return;

            customMarkersLayer.eachLayer(marker => {
                 if (handled) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    handled = true;
                    customMarkersLayer.removeLayer(marker);
                    marker.customColor = 'yes';
                    marker.levelPreset = document.getElementById('level-preset-select').value;
                    marker.baseColor = activeColor;
                    marker.setStyle({ fillOpacity: activeOpacity + 0.2, fillColor: marker.baseColor, color: marker.baseColor, weight: 2 });
                    warningMarkersLayer.addLayer(marker);
                }
            });
            if(handled) return;
            
            countyBoundariesLayer.getLayers().slice().reverse().forEach(layer => {
                if (handled || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    handled = true;
                    countyBoundariesLayer.removeLayer(layer);
                    layer.customColor = 'yes';
                    layer.levelPreset = document.getElementById('level-preset-select').value;
                    layer.baseColor = activeColor;
                    layer.options.baseWeight = 2;
                    if (layer.levelPreset === 'emergency') createEmergencyDash(layer);
                    layer.setStyle({ fillOpacity: activeOpacity, fillColor: layer.baseColor, color: layer.baseColor, weight: layer.options.baseWeight });
                    warningPolygonsLayer.addLayer(layer);
                }
            });
        });

        document.addEventListener('keydown', (event) => {
            if (document.activeElement && (document.activeElement.isContentEditable || /INPUT|TEXTAREA|SELECT/.test(document.activeElement.tagName))) return;

            if (event.key === 'Enter') {
                event.preventDefault();
                if (isDrawing) {
                    if (polygonDrawer.enabled()) polygonDrawer.completeShape();
                    if (markerDrawer.enabled()) markerDrawer.completeShape();
                }
                if (currentEditHandler) {
                    currentEditHandler.save();
                    currentEditHandler.disable();
                }
            } else if (event.key === 'Escape') {
                event.preventDefault();
                if (isDrawing) {
                    polygonDrawer.disable();
                    markerDrawer.disable();
                    isDrawing = false;
                }
                if (currentEditHandler) {
                    currentEditHandler.revertLayers();
                    currentEditHandler.disable();
                }
            }
        });

        document.getElementById('close-settings-button').addEventListener('click', () => document.getElementById('settings-modal').style.display = 'none');
        document.getElementById('close-about-button').addEventListener('click', () => document.getElementById('about-modal').style.display = 'none');
        document.getElementById('close-share-button').addEventListener('click', () => document.getElementById('share-modal').style.display = 'none');
        
        let resizeTimeout = null;
        window.addEventListener('resize', () => {
            let viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            let viewportHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            const sizer = document.getElementById("viewport-sizer");
            sizer.style.display = 'flex';
            sizer.innerHTML = `<b>${viewportWidth}</b> x <b>${viewportHeight}</b>`;
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => { sizer.style.display = 'none'; }, 1500);
        });

        const textOverlay = document.getElementById('text-overlay');
        const loaderOverlay = document.getElementById('loader-overlay');
        const settingsModal = document.getElementById('settings-modal');
        const shareModal = document.getElementById('share-modal');
        const aboutModal = document.getElementById('about-modal');

        function updateOverlayVisibility() {
            const isModalOpen = loaderOverlay.style.display !== 'none' || settingsModal.style.display !== 'none' || aboutModal.style.display !== 'none' || shareModal.style.display !== 'none';
            textOverlay.style.display = isModalOpen ? 'none' : 'block';
        }

        const modalObserver = new MutationObserver(updateOverlayVisibility);
        const observerConfig = { attributes: true, attributeFilter: ['style'] };
        modalObserver.observe(loaderOverlay, observerConfig);
        modalObserver.observe(settingsModal, observerConfig);
        modalObserver.observe(aboutModal, observerConfig);
        modalObserver.observe(shareModal, observerConfig);
        updateOverlayVisibility();

        const DEFAULT_OPACITY = 0.3;

        function updateActiveStyle() {
            const presetSelect = document.getElementById('color-preset-select');
            activeColor = (presetSelect.value === 'custom') 
                ? document.getElementById('custom-color-input').value 
                : presetSelect.value;
            activeOpacity = DEFAULT_OPACITY;
        }
        
        document.getElementById('color-preset-select').addEventListener('change', function() {
            document.getElementById('custom-color-picker-container').style.display = (this.value === 'custom') ? 'flex' : 'none';
            if (this.value !== 'custom') document.getElementById('custom-color-input').value = this.value;
            updateActiveStyle();
        });

        document.getElementById('custom-color-input').addEventListener('input', () => {
             if (document.getElementById('color-preset-select').value === 'custom') updateActiveStyle();
        });
        updateActiveStyle();

        function getPulseSize(preset) {
            switch (preset) {
                case 'considerable': return 2;
                case 'destructive':  return 5;
                case 'pds':          return 8;
                case 'emergency':    return 8;
                default:             return 0;
            }
        }

        function createEmergencyDash(originalLayer) {
            removeEmergencyDash(originalLayer);
            const dashPoly = L.polygon(originalLayer.getLatLngs(), {
                color: 'white', weight: 4, fill: false, dashArray: '8, 24', interactive: false,
            });
            dashPoly.original_id = originalLayer._leaflet_id;
            emergencyDashesGroup.addLayer(dashPoly);
        }

        function removeEmergencyDash(originalLayer) {
            let layerToRemove = null;
            emergencyDashesGroup.eachLayer(dashLayer => {
                if (dashLayer.original_id === originalLayer._leaflet_id) layerToRemove = dashLayer;
            });
            if (layerToRemove) emergencyDashesGroup.removeLayer(layerToRemove);
        }
        
        function animateAllShapes() {
            const cycleDuration = 2000;
            const timeInCycle = Date.now() % cycleDuration;
            const amplitude = (timeInCycle < cycleDuration / 2) 
                ? (timeInCycle / (cycleDuration / 2)) 
                : ((cycleDuration - timeInCycle) / (cycleDuration / 2));

            warningPolygonsLayer.eachLayer(layer => {
                if (layer instanceof L.Polygon && layer.customColor === 'yes' && layer.levelPreset) {
                    const baseWeight = layer.options.baseWeight || 2;
                    const pulseSize = getPulseSize(layer.levelPreset);
                    if (pulseSize > 0) layer.setStyle({ weight: baseWeight + (pulseSize * amplitude) });
                }
            });
            
            warningMarkersLayer.eachLayer(layer => {
                if (layer instanceof L.CircleMarker && layer.customColor === 'yes' && layer.levelPreset) {
                    const baseRadius = 6;
                    const pulseSize = getPulseSize(layer.levelPreset);
                     if (pulseSize > 0) layer.setRadius(baseRadius + (pulseSize * amplitude));
                }
            });
        }
        setInterval(animateAllShapes, 50);

        function enterSharedMode() {
            isSharedMode = true;
            const titleElement = document.querySelector('.text-overlay h2');
            const textElement = document.querySelector('.text-overlay p');
            titleElement.contentEditable = false;
            textElement.contentEditable = false;
            titleElement.classList.add('no-edit');
            textElement.classList.add('no-edit');
            document.getElementById('context-menu-new-polygon').style.display = 'none';
            document.getElementById('context-menu-new-marker').style.display = 'none';
            document.getElementById('context-menu-settings').style.display = 'none';
            document.getElementById('context-menu-edit').style.display = 'none';
            document.getElementById('context-menu-delete').style.display = 'none';
            document.getElementById('context-menu-share').style.display = 'none';
        }

        function updateShareUrl() {
            const shareSettings = document.getElementById('share-settings-checkbox').checked;
            const dataToShare = { polygons: [], markers: [], text: {} };

            warningPolygonsLayer.eachLayer(layer => {
                if (layer instanceof L.Polygon && layer.customColor === 'yes') {
                    dataToShare.polygons.push({
                        latlngs: layer.getLatLngs(), color: layer.baseColor, level: layer.levelPreset
                    });
                }
            });
            warningMarkersLayer.eachLayer(layer => {
                 if (layer instanceof L.CircleMarker && layer.customColor === 'yes') {
                    dataToShare.markers.push({
                        latlng: layer.getLatLng(), color: layer.baseColor, level: layer.levelPreset
                    });
                }
            });
            dataToShare.text.h2 = document.querySelector('.text-overlay h2').innerHTML;
            dataToShare.text.p = document.querySelector('.text-overlay p').innerHTML;

            if (shareSettings) {
                dataToShare.settings = {
                    mapStyle: (currentThemeLayer === lightThemeLayer) ? 'light' : 'dark',
                    radar: map.hasLayer(radarLayer),
                    zoom: map.getZoom(),
                    center: map.getCenter()
                };
            }
            
            const jsonString = JSON.stringify(dataToShare);
            const encodedData = btoa(unescape(encodeURIComponent(jsonString)));
            document.getElementById('share-url-input').value = `?data=${encodedData}`;
        }

        function loadDataFromUrl() {
            const data = new URLSearchParams(window.location.search).get('data');
            if (!data) return;

            try {
                const decodedData = decodeURIComponent(escape(atob(data)));
                const sharedData = JSON.parse(decodedData);
                enterSharedMode();

                if (sharedData.text) {
                    if (sharedData.text.h2) document.querySelector('.text-overlay h2').innerHTML = sharedData.text.h2;
                    if (sharedData.text.p) document.querySelector('.text-overlay p').innerHTML = sharedData.text.p;
                }
                if (sharedData.polygons && Array.isArray(sharedData.polygons)) {
                    sharedData.polygons.forEach(p => {
                        const polygon = L.polygon(p.latlngs, { isCustomPolygon: true }).addTo(warningPolygonsLayer);
                        polygon.customColor = 'yes';
                        polygon.levelPreset = p.level;
                        polygon.baseColor = p.color;
                        polygon.options.baseWeight = 2; 
                        polygon.setStyle({ fillOpacity: activeOpacity, fillColor: polygon.baseColor, color: polygon.baseColor, weight: polygon.options.baseWeight });
                        if (polygon.levelPreset === 'emergency') createEmergencyDash(polygon);
                    });
                }
                if (sharedData.markers && Array.isArray(sharedData.markers)) {
                     sharedData.markers.forEach(m => {
                        const marker = L.circleMarker(m.latlng, { isCustomMarker: true }).addTo(warningMarkersLayer);
                        marker.customColor = 'yes';
                        marker.levelPreset = m.level;
                        marker.baseColor = m.color;
                        marker.setStyle({ fillOpacity: activeOpacity + 0.2, fillColor: marker.baseColor, color: marker.baseColor, weight: 2, radius: 6 });
                    });
                }
                if (sharedData.settings) {
                    if (sharedData.settings.center && sharedData.settings.zoom) {
                        map.setView(sharedData.settings.center, sharedData.settings.zoom);
                    }
                    const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
                    const wantsLightTheme = sharedData.settings.mapStyle === 'light';
                    const isCurrentlyLight = currentThemeLayer === lightThemeLayer;
                    if (wantsLightTheme !== isCurrentlyLight) toggleMapTheme();
                    themeToggleCheckbox.checked = wantsLightTheme;

                    const radarToggleCheckbox = document.getElementById('radar-toggle-checkbox');
                    const wantsRadar = sharedData.settings.radar;
                    if (wantsRadar !== map.hasLayer(radarLayer)) toggleRadarLayer({ checked: wantsRadar });
                    radarToggleCheckbox.checked = wantsRadar;
                }
            } catch (error) {
                console.error("Failed to parse shared data from URL:", error);
                alert("Could not load the shared alert. The data may be corrupted.");
            }
        }
    </script>
</body>

</html>
