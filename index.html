<!DOCTYPE html>
<html lang="en">
<head>
    <title>TreeWarn</title>
    <link rel="icon" href="https://raw.githubusercontent.com/microsoft/fluentui-emoji/refs/heads/main/assets/Deciduous%20tree/3D/deciduous_tree_3d.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <link href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@maplibre/maplibre-gl-leaflet@0.0.21/leaflet-maplibre-gl.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Outfit', sans-serif;
        }
        body {
            overflow: hidden;
            margin: 0;
        }
        #map-container {
            z-index: 1;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0px;
            left: 0px;
        }
        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            width: max-content;
            overflow: hidden;
            color: white;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
        }
        .context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .context-menu ul li {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
        }
        .context-menu .material-symbols-outlined {
            padding-right: 10px;
        }
        .context-menu ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        button {
            padding: 4px;
            margin: 8px;
            background: rgb(254, 22, 103);
            color: black;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-size: large;
            width: 100px;
        }
        button:hover {
            background: rgb(255, 80, 120);
        }
        select {
            padding: 5px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: large;
        }
        .text-overlay {
            position: absolute;
            right: 0px;
            z-index: 1001;
            padding: 5px;
            margin: 10px;
            color: white;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
            width: fit-content;
            height: fit-content;
            max-height: calc(100vh - 30px);
            overflow: hidden;
        }
        .text-overlay h2,
        .text-overlay p {
            border-radius: 10px;
            padding: 10px;
            margin: 5px;
            border: none;
            white-space: pre-wrap;
            overflow: hidden;
        }
        .text-overlay h2:hover,
        .text-overlay p:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .text-overlay h2:focus,
        .text-overlay p:focus {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            outline: none;
        }
        .text-overlay .no-edit:hover {
            background-color: transparent;
            cursor: default;
        }
    </style>
</head>
<body>
    <div id="content">
        <div id="map-container"></div>
        <div class="text-overlay" id="text-overlay">
            <h2 contenteditable="true" spellcheck="false">Alert Title</h2>
            <p contenteditable="true" spellcheck="false">Alert Text</p>
        </div>
        <div id="loader-overlay" style="z-index: 100; flex-direction: column; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; color: white; display: flex; align-items: center; justify-content: center;">
            <h2>Loading...</h2>
        </div>
        <div id="settings-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>Settings</h1>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="theme-toggle-checkbox" onchange="toggleMapTheme();" type="checkbox"> Use light maps
                </div>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="radar-toggle-checkbox" onchange="toggleRadarLayer(this);" type="checkbox" checked> Radar
                </div>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="outlook-toggle-checkbox" onchange="toggleOutlookLayer(this);" type="checkbox"> SPC Day 1 Outlook
                </div>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="nws-warnings-toggle-checkbox" onchange="toggleNwsWarningsLayer(this);" type="checkbox" checked> NWS Warnings
                </div>
                <h3>Styles</h3>
                <div style="display: flex; flex-direction: column; align-items: left;">
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Color: </p>
                        <select id="color-preset-select" style="min-width: 150px;">
                            <option value="custom">Custom</option>
                            <option value="#FF0000">Tornado</option>
                            <option value="#FFA500">Severe</option>
                            <option value="#ADD8E6">Statement</option>
                            <option value="#FFFF00">Tropical</option>
                            <option value="#008080">Flash Flood</option>
                            <option value="#008000">Flood</option>
                            <option value="#8B0000">Tornado Watch</option>
                            <option value="#556B2F">Severe Watch</option>
                            <option value="#0000FF">Discussion</option>
                        </select>
                    </div>
                    <div id="custom-color-picker-container" style="display: flex; flex-direction: row; align-items: center; margin-top: 10px;">
                        <p style="margin: 0px 10px 0px 0px;">Custom Color: </p>
                        <input id="custom-color-input" type="color" value="#000000">
                    </div>
                    <br>
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Level: </p>
                        <select id="level-preset-select" style="min-width: 150px;">
                            <option value="standard">Standard</option>
                            <option value="considerable">Considerable</option>
                            <option value="destructive">Destructive</option>
                            <option value="pds">Particularly Dangerous</option>
                            <option value="emergency">Emergency</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                        <button id="close-settings-button">Close</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="share-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>Share</h1>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input id="share-settings-checkbox" onchange="updateShareUrl()" type="checkbox"> Share settings
                </div>
                <h3>Copy this URL modifier to share your alerts!</h3>
                <input type="text" id="share-url-input" style="width: 250px;">
                <div style="display: flex; flex-direction: column; align-items: left;">
                    <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                        <button id="close-share-button">Close</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="about-modal" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>About TreeWarn</h1>
                <p>TreeWarn is a simple tool for creating and visualizing your own weather alerts.</p>
                <p>This is a modified version of <a href="https://busybird15.github.io/sparkgen">SparkGen</a>, which was made by <a href="https://busybird15.github.io/">BusyBird15</a>.</p>
                <p>Radar data is from the <a href="https://mesonet.agron.iastate.edu/">Iowa Environmental Mesonet</a>.</p>
                <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                    <button id="close-about-button">Close</button>
                </div>
            </div>
        </div>
        <div id="context-menu" class="context-menu">
            <ul>
                <li id="context-menu-new-polygon"><i class="material-symbols-outlined">add</i>New Polygon</li>
                <li id="context-menu-new-marker"><i class="material-symbols-outlined">add_location</i>New Marker</li>
                <li id="context-menu-settings"><i class="material-symbols-outlined">settings</i>Settings</li>
                <li id="context-menu-about"><i class="material-symbols-outlined">info</i>About</li>
                <li id="context-menu-edit"><i class="material-symbols-outlined">edit</i>Edit</li>
                <li id="context-menu-delete"><i class="material-symbols-outlined">delete</i>Delete</li>
                <li id="context-menu-share"><i class="material-symbols-outlined">share</i>Share</li>
            </ul>
        </div>
    </div>
    <script>
        const map = L.map(document.getElementById("map-container"), {
            preferCanvas: true,
            doubleClickZoom: false,
            attributionControl: true,
            zoomControl: false,
            zoomSnap: 0,
            minZoom: 2
        }).setView([38.0, -100.4], 4);

        const southWest = L.latLng(-85, -180);
        const northEast = L.latLng(85, 180);
        const bounds = L.latLngBounds(southWest, northEast);
        map.setMaxBounds(bounds);
        map.on('drag', function() {
            map.panInsideBounds(bounds, {
                animate: false
            });
        });

        map.createPane('radar');
        map.getPane('radar').style.zIndex = 250;
        map.createPane('cities');
        map.getPane('cities').style.zIndex = 400;
        map.createPane('dashedLines');
        map.getPane('dashedLines').style.zIndex = 401;
        map.createPane('warnings');
        map.getPane('warnings').style.zIndex = 398;
		map.createPane('outlook');
        map.getPane('outlook').style.zIndex = 397;
        map.createPane('counties');
        map.getPane('counties').style.zIndex = 301;
        map.createPane('nwsWarnPane');
        map.getPane('nwsWarnPane').style.zIndex = 399;

        const emergencyDashesGroup = new L.FeatureGroup([], {
            pane: 'dashedLines'
        }).addTo(map);
        const warningPolygonsLayer = L.featureGroup([], {
            pane: 'warnings'
        }).addTo(map);
        const customMarkersLayer = L.featureGroup([], {
            pane: 'counties'
        }).addTo(map);
        const warningMarkersLayer = L.featureGroup([], {
            pane: 'warnings'
        }).addTo(map);
        let countyBoundariesLayer = L.geoJSON().addTo(map);
		let spcOutlookLayer = null;
        let nwsAlertsLayer = null;

        L.drawLocal.draw.handlers.polygon.tooltip.start = null;
        L.drawLocal.draw.handlers.polygon.tooltip.cont = null;
        L.drawLocal.draw.handlers.polygon.tooltip.end = null;
        L.drawLocal.draw.handlers.marker.tooltip.start = null;
        L.drawLocal.edit.handlers.edit.tooltip.text = null;
        L.drawLocal.edit.handlers.edit.tooltip.subtext = null;
        L.drawLocal.edit.handlers.remove.tooltip.text = null;

        const lightThemeLayer = L.maplibreGL({
            style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        });
        const darkThemeLayer = L.maplibreGL({
            style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        }).addTo(map);
        let currentThemeLayer = darkThemeLayer;

        const radarLayer = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
            layers: 'nexrad-n0r-900913',
            format: 'image/png',
            transparent: true,
            pane: 'radar',
            attribution: "IEM"
        }).addTo(map);

        setInterval(() => {
            if (map.hasLayer(radarLayer)) {
                radarLayer.setParams({
                    time: Date.now()
                });
            }
        }, 60000);

        function toggleMapTheme() {
            if (currentThemeLayer) {
                map.removeLayer(currentThemeLayer);
            }
            currentThemeLayer = (currentThemeLayer === lightThemeLayer) ? darkThemeLayer : lightThemeLayer;
            map.addLayer(currentThemeLayer);
        }

        function toggleRadarLayer(checkbox) {
            if (checkbox.checked) {
                map.addLayer(radarLayer);
            } else {
                map.removeLayer(radarLayer);
            }
        }
		
		function toggleOutlookLayer(checkbox) {
			if (checkbox.checked) {
				if (spcOutlookLayer && map.hasLayer(spcOutlookLayer)) return;
				
				if (!spcOutlookLayer) {
					fetch('https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson')
						.then(response => response.json())
						.then(data => {
							spcOutlookLayer = L.geoJSON(data, {
								style: function(feature) {
									return {
										color: feature.properties.stroke,
										weight: 2,
										fillColor: feature.properties.fill,
										fillOpacity: 0.5
									};
								},
								onEachFeature: function(feature, layer) {
									if (feature.properties && feature.properties.LABEL) {
										layer.bindPopup(`<b>${feature.properties.LABEL}</b><br>${feature.properties.LABEL2 || ''}`);
									}
								},
								pane: 'outlook'
							}).addTo(map);
						})
						.catch(error => console.error('Error loading SPC Outlook GeoJSON:', error));
				} else {
					map.addLayer(spcOutlookLayer);
				}
			} else {
				if (spcOutlookLayer && map.hasLayer(spcOutlookLayer)) {
					map.removeLayer(spcOutlookLayer);
				}
			}
		}

        function getNwsWarningColor(eventName) {
            const lowerEvent = eventName.toLowerCase();
            if (lowerEvent.includes('tornado warning')) return '#FF0000';
            if (lowerEvent.includes('tornado watch')) return '#FFFF00';
            if (lowerEvent.includes('severe thunderstorm warning')) return '#FFA500';
            if (lowerEvent.includes('severe thunderstorm watch')) return '#DB7093';
            if (lowerEvent.includes('flash flood')) return '#00FFFF';
            if (lowerEvent.includes('flood warning')) return '#00FF00';
            if (lowerEvent.includes('flood watch')) return '#228B22';
            if (lowerEvent.includes('special marine')) return '#FFA500';
            if (lowerEvent.includes('special weather statement')) return '#AFEEEE';
            return '#FFFFFF'; 
        }

        function toggleNwsWarningsLayer(checkbox) {
            if (checkbox.checked) {
                if (nwsAlertsLayer) {
                    map.addLayer(nwsAlertsLayer);
                } else {
                    fetch('https://api.weather.gov/alerts/active')
                        .then(response => response.json())
                        .then(data => {
                            nwsAlertsLayer = L.geoJSON(data, {
                                style: function(feature) {
                                    const color = getNwsWarningColor(feature.properties.event);
                                    return {
                                        color: color,
                                        weight: 2,
                                        fillColor: color,
                                        fillOpacity: 0.4
                                    };
                                },
                                onEachFeature: function(feature, layer) {
                                    if (feature.properties) {
                                        let popupContent = `<b>${feature.properties.event}</b><br>`;
                                        if (feature.properties.headline) popupContent += `${feature.properties.headline}<br>`;
                                        if (feature.properties.description) popupContent += `<br><i>${feature.properties.description}</i>`;
                                        layer.bindPopup(popupContent);
                                    }
                                },
                                pane: 'nwsWarnPane'
                            }).addTo(map);
                        })
                        .catch(error => console.error('Error loading NWS alerts:', error));
                }
            } else {
                if (nwsAlertsLayer) {
                    map.removeLayer(nwsAlertsLayer);
                }
            }
        }

        let activeColor = '#000000';
        let activeOpacity = 0.3;
        let isDrawing = false;
        let selectedPolygon = null;
        let selectedMarker = null;
        let isSharedMode = false;

        function reverseSubarrays(arr) {
            return arr.map(subArr => subArr.slice().reverse());
        }

        function styleCountyFeature(feature, layer) {
            layer.setStyle({
                color: 'black',
                fillOpacity: 0,
                weight: 0
            });
            layer.customColor = 'no';
        }

        fetch('https://raw.githubusercontent.com/12treesarecool34/treewarn/refs/heads/main/counties-simplified.json')
            .then(response => response.json())
            .then(data => {
                countyBoundariesLayer = L.geoJSON(data, {
                    onEachFeature: styleCountyFeature,
                    pane: 'counties'
                }).addTo(map);
                loadDataFromUrl();
                document.getElementById("loader-overlay").style.display = "none";
            })
            .catch(error => console.error('Error loading GeoJSON data:', error));

        let contextMenuX = 0;
        let contextMenuY = 0;

        function showContextMenu(event) {
            event.preventDefault();
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            contextMenuX = event.clientX;
            contextMenuY = event.clientY;
            if (contextMenuX + menuWidth > windowWidth) contextMenuX = windowWidth - menuWidth;
            if (contextMenuY + menuHeight > windowHeight) contextMenuY = windowHeight - menuHeight;
            if (contextMenuX < 0) contextMenuX = 0;
            if (contextMenuY < 0) contextMenuY = 0;
            menu.style.left = `${contextMenuX}px`;
            menu.style.top = `${contextMenuY}px`;
        }
        document.addEventListener('contextmenu', showContextMenu);

        document.getElementById('context-menu-new-polygon').addEventListener('click', () => {
            isDrawing = true;
            polygonDrawer.enable();
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-new-marker').addEventListener('click', () => {
            isDrawing = true;
            markerDrawer.enable();
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-settings').addEventListener('click', () => {
            document.getElementById('settings-modal').style.display = 'flex';
            document.getElementById('text-overlay').style.display = 'none';
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-share').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'flex';
            document.getElementById('text-overlay').style.display = 'none';
            document.getElementById('context-menu').style.display = 'none';
            updateShareUrl();
        });

        document.getElementById('context-menu-about').addEventListener('click', () => {
            document.getElementById('about-modal').style.display = 'flex';
            document.getElementById('text-overlay').style.display = 'none';
            document.getElementById('context-menu').style.display = 'none';
        });

        const featureGroupForEditing = new L.FeatureGroup().addTo(map);
        let currentEditHandler = null;

        document.getElementById('context-menu-edit').addEventListener('click', () => {
            let layerToEdit = selectedPolygon || selectedMarker;
            if (layerToEdit && (layerToEdit.isCustomPolygon || layerToEdit.isCustomMarker)) {
                if (layerToEdit.isCustomPolygon) {
                    removeEmergencyDash(layerToEdit);
                    if (warningPolygonsLayer.hasLayer(layerToEdit)) warningPolygonsLayer.removeLayer(layerToEdit);
                    else if (countyBoundariesLayer.hasLayer(layerToEdit)) countyBoundariesLayer.removeLayer(layerToEdit);
                } else {
                    if (warningMarkersLayer.hasLayer(layerToEdit)) warningMarkersLayer.removeLayer(layerToEdit);
                    else if (customMarkersLayer.hasLayer(layerToEdit)) customMarkersLayer.removeLayer(layerToEdit);
                }
                featureGroupForEditing.addLayer(layerToEdit);
                currentEditHandler = new L.EditToolbar.Edit(map, {
                    featureGroup: featureGroupForEditing
                });
                currentEditHandler.enable();
            }
            document.getElementById('context-menu').style.display = 'none';
        });

        document.getElementById('context-menu-delete').addEventListener('click', () => {
            if (selectedPolygon && selectedPolygon.isCustomPolygon) {
                removeEmergencyDash(selectedPolygon);
                if (warningPolygonsLayer.hasLayer(selectedPolygon)) warningPolygonsLayer.removeLayer(selectedPolygon);
                if (countyBoundariesLayer.hasLayer(selectedPolygon)) countyBoundariesLayer.removeLayer(selectedPolygon);
            }
            if (selectedMarker && selectedMarker.isCustomMarker) {
                if (warningMarkersLayer.hasLayer(selectedMarker)) warningMarkersLayer.removeLayer(selectedMarker);
                if (customMarkersLayer.hasLayer(selectedMarker)) customMarkersLayer.removeLayer(selectedMarker);
            }
            document.getElementById('context-menu').style.display = 'none';
        });

        const polygonDrawer = new L.Draw.Polygon(map, {});
        const markerDrawer = new L.Draw.Marker(map, {
            icon: new L.DivIcon({
                className: 'leaflet-draw-marker-icon',
                iconSize: [20, 20]
            })
        });

        map.on('draw:created', (event) => {
            isDrawing = false;
            const type = event.layerType;
            const layer = event.layer;
            if (type === 'polygon') {
                const polygon = L.polygon(reverseSubarrays(layer.toGeoJSON()['geometry']['coordinates'][0]), {
                    color: 'black',
                    pane: 'counties',
                    fillOpacity: 0,
                    weight: 2
                }).addTo(countyBoundariesLayer);
                polygon.customColor = 'no';
                polygon.isCustomPolygon = true;
            } else if (type === 'marker') {
                const marker = L.circleMarker(layer.getLatLng(), {
                    radius: 6,
                    color: 'black',
                    weight: 2,
                    fillColor: 'grey',
                    fillOpacity: 0.5,
                    pane: 'counties'
                }).addTo(customMarkersLayer);
                marker.customColor = 'no';
                marker.isCustomMarker = true;
            }
        });

        map.on('draw:canceled', () => isDrawing = false);

        map.on(L.Draw.Event.EDITSTOP, () => {
            const layersToAddBack = [];
            featureGroupForEditing.eachLayer(layer => {
                layersToAddBack.push(layer);
                if (layer instanceof L.Polygon && layer.customColor === 'yes' && layer.levelPreset === 'emergency') {
                    createEmergencyDash(layer);
                }
            });
            featureGroupForEditing.clearLayers();
            layersToAddBack.forEach(layer => {
                const isWarning = layer.customColor === 'yes';
                const isPolygon = layer instanceof L.Polygon;
                if (isWarning) {
                    if (isPolygon) warningPolygonsLayer.addLayer(layer);
                    else warningMarkersLayer.addLayer(layer);
                } else {
                    if (isPolygon) countyBoundariesLayer.addLayer(layer);
                    else customMarkersLayer.addLayer(layer);
                }
            });
            currentEditHandler = null;
        });

        map.on('contextmenu', (event) => {
            const clickedPoint = event.latlng;
            const clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            let foundPolygon = false;
            let foundMarker = false;
            selectedPolygon = null;
            selectedMarker = null;
            const editMenuItem = document.getElementById('context-menu-edit');
            const deleteMenuItem = document.getElementById('context-menu-delete');
            const checkMarker = (marker) => {
                if (foundMarker) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    foundMarker = true;
                    selectedMarker = marker;
                }
            };
            warningMarkersLayer.eachLayer(checkMarker);
            if (!foundMarker) customMarkersLayer.eachLayer(checkMarker);
            const checkPolygon = (layer) => {
                if (foundPolygon || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    foundPolygon = true;
                    selectedPolygon = layer;
                }
            };
            if (!foundMarker) {
                warningPolygonsLayer.getLayers().slice().reverse().forEach(checkPolygon);
                if (!foundPolygon) {
                    countyBoundariesLayer.getLayers().slice().reverse().forEach(checkPolygon);
                }
            }
            const isCustom = (selectedPolygon && selectedPolygon.isCustomPolygon) || (selectedMarker && selectedMarker.isCustomMarker);
            editMenuItem.style.display = isCustom ? 'flex' : 'none';
            deleteMenuItem.style.display = isCustom ? 'flex' : 'none';
        });

        map.on('click', (event) => {
            const contextMenu = document.getElementById('context-menu');
            if (contextMenu.style.display !== 'none') {
                contextMenu.style.display = 'none';
                return;
            }
            if (isSharedMode || isDrawing || currentEditHandler) return;
            const clickedPoint = event.latlng;
            const clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            let handled = false;
            warningMarkersLayer.eachLayer(marker => {
                if (handled) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    handled = true;
                    warningMarkersLayer.removeLayer(marker);
                    marker.setStyle({
                        radius: 6,
                        color: 'black',
                        weight: 2,
                        fillColor: 'grey',
                        fillOpacity: 0.5
                    });
                    marker.customColor = 'no';
                    marker.levelPreset = null;
                    marker.baseColor = null;
                    customMarkersLayer.addLayer(marker);
                }
            });
            if (handled) return;
            warningPolygonsLayer.getLayers().slice().reverse().forEach(layer => {
                if (handled || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    handled = true;
                    warningPolygonsLayer.removeLayer(layer);
                    removeEmergencyDash(layer);
                    const newWeight = layer.isCustomPolygon ? 2 : 0;
                    layer.setStyle({
                        fillOpacity: 0,
                        color: 'black',
                        weight: newWeight
                    });
                    layer.customColor = 'no';
                    layer.levelPreset = null;
                    layer.baseColor = null;
                    delete layer.options.baseWeight;
                    countyBoundariesLayer.addLayer(layer);
                }
            });
            if (handled) return;
            customMarkersLayer.eachLayer(marker => {
                if (handled) return;
                const center = marker.getLatLng();
                const radius = marker.getRadius();
                const distance = map.latLngToLayerPoint(center).distanceTo(map.latLngToLayerPoint(clickedPoint));
                if (distance <= radius) {
                    handled = true;
                    customMarkersLayer.removeLayer(marker);
                    marker.customColor = 'yes';
                    marker.levelPreset = document.getElementById('level-preset-select').value;
                    marker.baseColor = activeColor;
                    marker.setStyle({
                        fillOpacity: activeOpacity + 0.2,
                        fillColor: marker.baseColor,
                        color: marker.baseColor,
                        weight: 2
                    });
                    warningMarkersLayer.addLayer(marker);
                }
            });
            if (handled) return;
            countyBoundariesLayer.getLayers().slice().reverse().forEach(layer => {
                if (handled || !(layer instanceof L.Polygon)) return;
                if (turf.booleanPointInPolygon(clickedPointGeoJSON, layer.toGeoJSON())) {
                    handled = true;
                    countyBoundariesLayer.removeLayer(layer);
                    layer.customColor = 'yes';
                    layer.levelPreset = document.getElementById('level-preset-select').value;
                    layer.baseColor = activeColor;
                    layer.options.baseWeight = 2;
                    layer.setStyle({
                        fillOpacity: activeOpacity,
                        fillColor: layer.baseColor,
                        color: layer.baseColor,
                        weight: layer.options.baseWeight
                    });
                    warningPolygonsLayer.addLayer(layer);
                    if (layer.levelPreset === 'emergency') createEmergencyDash(layer);
                }
            });
        });

        document.addEventListener('keydown', (event) => {
            if (document.activeElement && (document.activeElement.isContentEditable || /INPUT|TEXTAREA|SELECT/.test(document.activeElement.tagName))) return;
            if (event.key === 'Enter') {
                event.preventDefault();
                if (isDrawing) {
                    if (polygonDrawer.enabled()) polygonDrawer.completeShape();
                    if (markerDrawer.enabled()) markerDrawer.completeShape();
                }
                if (currentEditHandler) {
                    currentEditHandler.save();
                    currentEditHandler.disable();
                }
            } else if (event.key === 'Escape') {
                event.preventDefault();
                if (isDrawing) {
                    polygonDrawer.disable();
                    markerDrawer.disable();
                    isDrawing = false;
                }
                if (currentEditHandler) {
                    currentEditHandler.revertLayers();
                    currentEditHandler.disable();
                }
            }
        });

        document.getElementById('close-settings-button').addEventListener('click', () => {
            document.getElementById('settings-modal').style.display = 'none';
            document.getElementById('text-overlay').style.display = 'block';
        });
        document.getElementById('close-about-button').addEventListener('click', () => {
            document.getElementById('about-modal').style.display = 'none';
            document.getElementById('text-overlay').style.display = 'block';
        });
        document.getElementById('close-share-button').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
            document.getElementById('text-overlay').style.display = 'block';
        });

        const DEFAULT_OPACITY = 0.3;

        function updateActiveStyle() {
            const presetSelect = document.getElementById('color-preset-select');
            activeColor = (presetSelect.value === 'custom') ?
                document.getElementById('custom-color-input').value :
                presetSelect.value;
            activeOpacity = DEFAULT_OPACITY;
        }

        document.getElementById('color-preset-select').addEventListener('change', function() {
            document.getElementById('custom-color-picker-container').style.display = (this.value === 'custom') ? 'flex' : 'none';
            if (this.value !== 'custom') document.getElementById('custom-color-input').value = this.value;
            updateActiveStyle();
        });

        document.getElementById('custom-color-input').addEventListener('input', () => {
            if (document.getElementById('color-preset-select').value === 'custom') updateActiveStyle();
        });
        updateActiveStyle();

        function getPulseSize(preset) {
            switch (preset) {
                case 'considerable':
                    return 2;
                case 'destructive':
                    return 5;
                case 'pds':
                    return 8;
                case 'emergency':
                    return 8;
                default:
                    return 0;
            }
        }

        function createEmergencyDash(originalLayer) {
            removeEmergencyDash(originalLayer);
            const dashPoly = L.polygon(originalLayer.getLatLngs(), {
                color: 'white',
                weight: 4,
                fill: false,
                dashArray: '8, 24',
                interactive: false,
            });
            dashPoly.original_id = originalLayer._leaflet_id;
            emergencyDashesGroup.addLayer(dashPoly);
        }

        function removeEmergencyDash(originalLayer) {
            let layerToRemove = null;
            emergencyDashesGroup.eachLayer(dashLayer => {
                if (dashLayer.original_id === originalLayer._leaflet_id) layerToRemove = dashLayer;
            });
            if (layerToRemove) emergencyDashesGroup.removeLayer(layerToRemove);
        }

        function animateAllShapes() {
            const cycleDuration = 2000;
            const timeInCycle = Date.now() % cycleDuration;
            const amplitude = (timeInCycle < cycleDuration / 2) ?
                (timeInCycle / (cycleDuration / 2)) :
                ((cycleDuration - timeInCycle) / (cycleDuration / 2));
            warningPolygonsLayer.eachLayer(layer => {
                if (layer instanceof L.Polygon && layer.customColor === 'yes' && layer.levelPreset) {
                    const baseWeight = layer.options.baseWeight || 2;
                    const pulseSize = getPulseSize(layer.levelPreset);
                    if (pulseSize > 0) layer.setStyle({
                        weight: baseWeight + (pulseSize * amplitude)
                    });
                }
            });
            warningMarkersLayer.eachLayer(layer => {
                if (layer instanceof L.CircleMarker && layer.customColor === 'yes' && layer.levelPreset) {
                    const baseRadius = 6;
                    const pulseSize = getPulseSize(layer.levelPreset);
                    if (pulseSize > 0) layer.setRadius(baseRadius + (pulseSize * amplitude));
                }
            });
        }
        setInterval(animateAllShapes, 50);

        function enterSharedMode() {
            isSharedMode = true;
            const titleElement = document.querySelector('.text-overlay h2');
            const textElement = document.querySelector('.text-overlay p');
            titleElement.contentEditable = false;
            textElement.contentEditable = false;
            titleElement.classList.add('no-edit');
            textElement.classList.add('no-edit');
            document.getElementById('context-menu-new-polygon').style.display = 'none';
            document.getElementById('context-menu-new-marker').style.display = 'none';
            document.getElementById('context-menu-settings').style.display = 'none';
            document.getElementById('context-menu-edit').style.display = 'none';
            document.getElementById('context-menu-delete').style.display = 'none';
            document.getElementById('context-menu-share').style.display = 'none';
        }

        function updateShareUrl() {
            const shareSettings = document.getElementById('share-settings-checkbox').checked;
            const dataToShare = {
                p: [],
                m: [],
                t: {
                    h2: document.querySelector('.text-overlay h2').innerHTML,
                    p: document.querySelector('.text-overlay p').innerHTML
                }
            };

            const processedLayerIds = new Set();
            [...warningPolygonsLayer.getLayers(), ...countyBoundariesLayer.getLayers()].forEach(layer => {
                if (layer instanceof L.Polygon && !processedLayerIds.has(layer._leaflet_id)) {
                    if (layer.isCustomPolygon || layer.customColor === 'yes') {
                        const latlngs = layer.getLatLngs();
                        let finalLatLngs;
                        
                        const firstEl = latlngs[0];
                        if (firstEl && Array.isArray(firstEl)) {
                            finalLatLngs = latlngs.map(ring => ring.map(p => [Number(p.lat.toFixed(5)), Number(p.lng.toFixed(5))]));
                        } else if (firstEl) {
                            finalLatLngs = [latlngs.map(p => [Number(p.lat.toFixed(5)), Number(p.lng.toFixed(5))])];
                        } else {
                            finalLatLngs = [];
                        }

                        dataToShare.p.push({
                            ll: finalLatLngs,
                            c: layer.baseColor || null,
                            l: layer.levelPreset || null,
                            i: !!layer.isCustomPolygon
                        });
                        processedLayerIds.add(layer._leaflet_id);
                    }
                }
            });
            [...warningMarkersLayer.getLayers(), ...customMarkersLayer.getLayers()].forEach(layer => {
                if (layer instanceof L.CircleMarker && !processedLayerIds.has(layer._leaflet_id)) {
                    if (layer.isCustomMarker) {
                         const markerLatLng = layer.getLatLng();
                        dataToShare.m.push({
                            ll: [Number(markerLatLng.lat.toFixed(5)), Number(markerLatLng.lng.toFixed(5))],
                            c: layer.baseColor || null,
                            l: layer.levelPreset || null,
                        });
                        processedLayerIds.add(layer._leaflet_id);
                    }
                }
            });

            if (shareSettings) {
                const center = map.getCenter();
                dataToShare.s = {
                    t: (currentThemeLayer === lightThemeLayer) ? 'l' : 'd',
                    r: document.getElementById('radar-toggle-checkbox').checked,
                    o: document.getElementById('outlook-toggle-checkbox').checked,
                    w: document.getElementById('nws-warnings-toggle-checkbox').checked,
                    z: map.getZoom(),
                    c: [Number(center.lat.toFixed(5)), Number(center.lng.toFixed(5))]
                };
            }
            const jsonString = JSON.stringify(dataToShare);
            const compressed = pako.deflate(jsonString);
            const encodedData = btoa(String.fromCharCode.apply(null, compressed));
            const urlSafeEncodedData = encodedData.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            
            document.getElementById('share-url-input').value = `?data=${urlSafeEncodedData}`;
        }

        function loadDataFromUrl() {
            const data = new URLSearchParams(window.location.search).get('data');
            if (!data) return;
            try {
                let base64 = data.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4) {
                    base64 += '=';
                }
                const compressed = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                const decodedData = pako.inflate(compressed, { to: 'string' });
                const sharedData = JSON.parse(decodedData);
                enterSharedMode();

                if (sharedData.t) {
                    if (sharedData.t.h2) document.querySelector('.text-overlay h2').innerHTML = sharedData.t.h2;
                    if (sharedData.t.p) document.querySelector('.text-overlay p').innerHTML = sharedData.t.p;
                }
                if (sharedData.p && Array.isArray(sharedData.p)) {
                    sharedData.p.forEach(p => {
                        let polygonToStyle;
                        const latlngs = p.ll;

                        if (p.i) {
                            polygonToStyle = L.polygon(latlngs, { isCustomPolygon: true });
                        } else {
                            try {
                                const turfCoords = latlngs.map(ring => ring.map(ll => [ll[1], ll[0]]));
                                const tempGeoJSON = { type: 'Polygon', coordinates: turfCoords };
                                const center = turf.centerOfMass(tempGeoJSON);
                                countyBoundariesLayer.eachLayer(layer => {
                                    if (polygonToStyle) return;
                                    if (turf.booleanPointInPolygon(center, layer.toGeoJSON())) {
                                        polygonToStyle = layer;
                                    }
                                });
                                if (polygonToStyle) countyBoundariesLayer.removeLayer(polygonToStyle);
                            } catch (e) {
                                console.error("Could not find center of pre-loaded polygon, creating new one.", e);
                                polygonToStyle = L.polygon(latlngs, { isCustomPolygon: false });
                            }
                        }
                        if (!polygonToStyle) return;
                        
                        if (p.c) {
                            polygonToStyle.customColor = 'yes';
                            polygonToStyle.levelPreset = p.l;
                            polygonToStyle.baseColor = p.c;
                            polygonToStyle.options.baseWeight = 2;
                            polygonToStyle.setStyle({
                                fillOpacity: activeOpacity,
                                fillColor: polygonToStyle.baseColor,
                                color: polygonToStyle.baseColor,
                                weight: polygonToStyle.options.baseWeight
                            });
                            warningPolygonsLayer.addLayer(polygonToStyle);
                            if (polygonToStyle.levelPreset === 'emergency') {
                                createEmergencyDash(polygonToStyle);
                            }
                        } else {
                            polygonToStyle.customColor = 'no';
                            polygonToStyle.setStyle({ color: 'black', fillOpacity: 0, weight: 2, pane: 'counties' });
                            countyBoundariesLayer.addLayer(polygonToStyle);
                        }
                    });
                }
                if (sharedData.m && Array.isArray(sharedData.m)) {
                    sharedData.m.forEach(m => {
                        const marker = L.circleMarker(m.ll, { isCustomMarker: true });
                        if (m.c) {
                            marker.customColor = 'yes';
                            marker.levelPreset = m.l;
                            marker.baseColor = m.c;
                            marker.setStyle({
                                fillOpacity: activeOpacity + 0.2,
                                fillColor: marker.baseColor,
                                color: marker.baseColor,
                                weight: 2,
                                radius: 6
                            });
                            warningMarkersLayer.addLayer(marker);
                        } else {
                            marker.customColor = 'no';
                            marker.setStyle({ radius: 6, color: 'black', weight: 2, fillColor: 'grey', fillOpacity: 0.5, pane: 'counties' });
                            customMarkersLayer.addLayer(marker);
                        }
                    });
                }
                if (sharedData.s) {
                    if (sharedData.s.c && sharedData.s.z) {
                        map.setView(sharedData.s.c, sharedData.s.z);
                    }
                    const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
                    const wantsLightTheme = sharedData.s.t === 'l';
                    const isCurrentlyLight = currentThemeLayer === lightThemeLayer;
                    if (wantsLightTheme !== isCurrentlyLight) toggleMapTheme();
                    themeToggleCheckbox.checked = wantsLightTheme;
                    
                    const radarToggleCheckbox = document.getElementById('radar-toggle-checkbox');
                    const wantsRadar = sharedData.s.r;
                    if (wantsRadar !== map.hasLayer(radarLayer)) toggleRadarLayer({ checked: wantsRadar });
                    radarToggleCheckbox.checked = wantsRadar;

					const outlookToggleCheckbox = document.getElementById('outlook-toggle-checkbox');
                    if (sharedData.s.o) {
						toggleOutlookLayer({ checked: true });
						outlookToggleCheckbox.checked = true;
					}

                    const nwsWarningsToggleCheckbox = document.getElementById('nws-warnings-toggle-checkbox');
                    if (sharedData.s.w) {
                        toggleNwsWarningsLayer({ checked: true });
                        nwsWarningsToggleCheckbox.checked = true;
                    }
                }
            } catch (error) {
                console.error("Failed to parse shared data from URL:", error);
                alert("Could not load the shared alert. The data may be corrupted.");
            }
        }
    </script>
</body>
</html>
