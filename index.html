<!DOCTYPE html>
<html lang="en">

<head>
    <title>SparkGen</title>
    <link rel="icon" href="https://raw.githubusercontent.com/busybird15/busybird15.github.io/main/beta/sparkradar/logo-rounded.png"/>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Leaflet & Leaflet.draw -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.js"></script>

    <!-- Turf.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.6/turf.min.js"></script>

    <!-- MapTiler SDK -->
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v2.0.0/leaflet-maptilersdk.js"></script>

    <!-- Google Icons & Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">

    <!-- CSS -->
    <style>
        * {
            font-family: 'Outfit', sans-serif;
        }

        body {
            overflow: hidden;
        }

        #mapid {
            z-index: 1;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0px;
            left: 0px;
        }

        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            width: max-content;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        .context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .context-menu ul li {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
        }

        .context-menu .material-symbols-outlined {
            padding-right: 10px;
        }

        .context-menu ul li:hover {
            background-color: #eee;
        }

        button {
            padding: 4px;
            margin: 8px;
            background: rgb(254, 22, 103);
            color: black;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: large;
            width: 100px;
        }

        button:hover {
            background: rgb(255, 80, 120);
        }

        select {
            padding: 5px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: large;
        }

        textarea {
            padding: 5px;
            border-radius: 5px;
            font-size: medium;
        }

        .editable-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
            padding: 10px;
            color: white;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 5px;
            width: fit-content;
            height: fit-content;
            max-width: calc(100vw - 20px);
            max-height: calc(100vh - 40px);
            overflow: hidden;
        }

        .editable-overlay h2,
        .editable-overlay p {
            margin-top: 0;
            margin-bottom: 0;
            padding: 5px;
            border: 1px solid transparent;
            white-space: pre-wrap;
            overflow: hidden;
        }

        .editable-overlay h2:hover,
        .editable-overlay p:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .editable-overlay h2:focus,
        .editable-overlay p:focus {
            border: 1px dashed white;
            outline: none;
        }
    </style>
</head>

<body>
    <div id="content">

        <div id="mapid"></div>

        <div class="editable-overlay" id="editableOverlay">
            <h2 contenteditable="true" spellcheck="false">Title</h2>
            <p contenteditable="true" spellcheck="false">Subtitle</p>
        </div>

        <div id="loader" style="z-index: 100; flex-direction: column; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background: black; color: white; display: flex; align-items: center; justify-content: center;">
            <h2>Loading...</h2>
            <p style="width: 70%; text-align: center;">We're downloading the county database. This may take some time but only needs to be done once.</p>
            <div style="width: 200px; height: 10px; background: rgb(90, 90, 90); border-radius: 10px;">
                <div id="loadingprog" style="height: 10px; background: white; border-radius: 10px;"></div>
            </div>
            <p id="textprog">0%</p>
        </div>

        <div id="style" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>Settings</h1>
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <input onchange="changemap();" type="checkbox"> Use light maps
                </div>
                <h3>Styles</h3>
                <div style="display: flex; flex-direction: column; align-items: left;">
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Color: </p>
                        <select id="stylePreset" style="min-width: 150px;">
                            <option value="custom">Custom</option>
                            <option value="#FF0000">Tornado</option>
                            <option value="#FFA500">Severe</option>
                            <option value="#ADD8E6">Statement</option>
                            <option value="#FFFF00">Tropical</option>
                            <option value="#008080">Flash Flood</option>
                            <option value="#008000">Flood</option>
                            <option value="#8B0000">Tornado Watch</option>
                            <option value="#556B2F">Severe Watch</option>
                            <option value="#0000FF">Discussion</option>
                        </select>
                    </div>
                    <div id="customColorPicker" style="display: flex; flex-direction: row; align-items: center; margin-top: 10px;">
                        <p style="margin: 0px 10px 0px 0px;">Custom Color: </p>
                        <input id="styleColor" type="color" value="#FFFFFF">
                    </div>
                    <br>
                    <div style="display: flex; flex-direction: row; align-items: center;">
                        <p style="margin: 0px 10px 0px 0px;">Level: </p>
                        <select id="levelPreset" style="min-width: 150px;">
                            <option value="standard">Standard</option>
                            <option value="considerable">Considerable</option>
                            <option value="destructive">Destructive</option>
                            <option value="pds">Particularly Dangerous</option>
                            <option value="emergency">Emergency</option>
                        </select>
                    </div>

                    <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                        <button id="closeSettings">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="about" style="z-index: 100; overflow-y: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none;">
            <div style="display: flex; flex-direction: column; width: 100%; max-width: 100%; padding: 20px; box-sizing: border-box;">
                <h1>About SparkGen</h1>
                <p>SparkGen is a tool for creating and visualizing weather-related map overlays.</p>
                <p>This is a modified version of the <a href="https://busybird15.github.io/sparkgen">original SparkGen</a>, which was made by <a href="https://busybird15.github.io/">BusyBird15</a>.</p>
                <div style="display: flex; flex-direction: row; gap: 10px; margin-top: 20px;">
                    <button id="closeAbout">Close</button>
                </div>
            </div>
        </div>

        <div id="infopiece" style="padding: 10px; color: white; z-index: 1000; overflow: auto; flex-direction: column; position: absolute; margin: 0px; top: 0px; left: 0px; width: auto; height: auto; border-radius: 5px; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);"></div>

        <div id="custom-context-menu" class="context-menu">
            <ul>
                <li id="menu-item-1"><i class="material-symbols-outlined">add</i> Add Polygon</li>
                <li id="menu-item-2"><i class="material-symbols-outlined">settings</i>Settings</li>
                <li id="menu-item-3"><i class="material-symbols-outlined">info</i>About</li>
                <li id="menu-item-4"><i class="material-symbols-outlined">delete</i>Remove Polygon</li>
            </ul>
        </div>

        <div id="sizer" style="font-size: larger; z-index: 1000; justify-content: center; flex-direction: row; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background: rgb(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; display: none; align-items: center;">
            200x200
        </div>

    </div>

    <script>
        var map = L.map(document.getElementById("mapid"), {
            preferCanvas: true,
            doubleClickZoom: false,
            attributionControl: true,
            zoomControl: false,
            zoomSnap: 0,
            minZoom: 2
        }).setView([38.0, -100.4], 4);

        var southWest = L.latLng(-85, -180);
        var northEast = L.latLng(85, 180);
        var bounds = L.latLngBounds(southWest, northEast);
        map.setMaxBounds(bounds);

        map.createPane('cities');
        map.getPane('cities').style.zIndex = 400;
        map.createPane('counties');
        map.getPane('counties').style.zIndex = 301;

        var counties = L.geoJSON().addTo(map);

        map.on('drag', function() {
            map.panInsideBounds(bounds, {
                animate: false
            });
        });

        var map_default = L.maptilerLayer({
            apiKey: "UMONrX6MjViuKZoR882u",
            style: '96084695-6598-45c9-8f28-a3e091d9275c',
        });

        var map_darkmaterial = L.maptilerLayer({
            apiKey: "UMONrX6MjViuKZoR882u",
            style: '6203b2a0-063f-44b0-95f7-8c69393a3a46',
        }).addTo(map);

        var currentMapLayer = map_darkmaterial;

        function changemap() {
            if (currentMapLayer) {
                map.removeLayer(currentMapLayer);
            }

            if (currentMapLayer == map_default) {
                currentMapLayer = map_darkmaterial;
            } else {
                currentMapLayer = map_default;
            }

            map.addLayer(currentMapLayer);
        }

        var clickColor = '#FFFFFF';
        var clickOpacity = 0.3;
        var isDrawing = false;
        var selectedPolygon = null;

        function reverseSubarrays(arr) {
            return arr.map(subArr => subArr.slice().reverse());
        }

        function perFeature(feature, layer) {
            layer.setStyle({
                color: 'black',
                fillOpacity: 0,
                weight: 2
            });
            layer.customColor = 'no';
        }

        fetch('https://busybird15.github.io/assets/countymaps/counties-simplified.json')
            .then(response => response.json())
            .then(data => {
                counties = L.geoJSON(data, {
                    onEachFeature: perFeature,
                    pane: 'counties'
                }).addTo(map);
                document.getElementById("loader").style.display = "none";
            })
            .catch(error => {
                console.error('Error loading GeoJSON data:', error);
            });

        var citylayer = L.maptilerLayer({
            apiKey: "UMONrX6MjViuKZoR882u",
            style: '3077107e-833d-4087-999c-3b42c3ec5b13',
            pane: "cities",
            navigationControl: false,
            geolocateControl: false,
        }).addTo(map);
        citylayer.getContainer().style.pointerEvents = 'none';

        let x = 0;
        let y = 0;

        function rClick(e) {
            e.preventDefault();

            const menu = document.getElementById('custom-context-menu');
            menu.style.display = 'block';

            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            x = e.clientX;
            y = e.clientY;

            if (x + menuWidth > windowWidth) {
                x = windowWidth - menuWidth;
            }
            if (y + menuHeight > windowHeight) {
                y = windowHeight - menuHeight;
            }
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }

            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
        }

        document.addEventListener('contextmenu', rClick);
        document.getElementById('infopiece').style.display = 'none';

        document.getElementById('menu-item-1').addEventListener('click', function() {
            isDrawing = true;
            document.getElementById('infopiece').innerHTML = "Press (esc) to cancel.";
            document.getElementById('infopiece').style.display = 'block';
            setTimeout(() => document.getElementById('infopiece').style.display = 'none', 3000);
            drawPolygon.enable();
            document.getElementById('custom-context-menu').style.display = 'none';
        });

        document.getElementById('menu-item-2').addEventListener('click', function() {
            document.getElementById('style').style.display = 'flex';
            document.getElementById('custom-context-menu').style.display = 'none';
        });

        document.getElementById('menu-item-3').addEventListener('click', function() {
            document.getElementById('about').style.display = 'flex';
            document.getElementById('custom-context-menu').style.display = 'none';
        });

        document.getElementById('menu-item-4').addEventListener('click', function() {
            if (selectedPolygon && selectedPolygon.isCustomPolygon) {
                counties.removeLayer(selectedPolygon);
            }
            document.getElementById('custom-context-menu').style.display = 'none';
        });

        document.getElementById('closeSettings').addEventListener('click', function() {
            document.getElementById('style').style.display = 'none';
        });

        document.getElementById('closeAbout').addEventListener('click', function() {
            document.getElementById('about').style.display = 'none';
        });

        var drawControl = new L.Control.Draw({
            edit: false,
            draw: false
        });
        map.addControl(drawControl);

        var drawPolygon = new L.Draw.Polygon(map, drawControl.options.draw.polygon);

        map.on('draw:created', function(e) {
            var layer = e.layer;
            isDrawing = false;

            var polygon = L.polygon(reverseSubarrays(layer.toGeoJSON()['geometry']['coordinates'][0]), {
                color: 'black',
                pane: 'counties',
                fillOpacity: 0
            }).addTo(counties);
            polygon.customColor = 'no';
            polygon.isCustomPolygon = true;
        });

        map.on('draw:canceled', function(e) {
            isDrawing = false;
        });

        map.on('contextmenu', function(e) {
            var clickedPoint = e.latlng;
            var clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            var foundPolygon = false;

            var reversedLayers = counties.getLayers().slice().reverse();

            reversedLayers.forEach(function(layer) {
                if (layer instanceof L.Polygon && !foundPolygon) {
                    var polygonGeoJSON = layer.toGeoJSON();
                    var isInside = turf.booleanPointInPolygon(clickedPointGeoJSON, polygonGeoJSON);
                    if (isInside) {
                        foundPolygon = true;
                        selectedPolygon = layer;
                        document.getElementById('menu-item-4').style.display = layer.isCustomPolygon ? 'flex' : 'none';
                    }
                }
            });

            if (!foundPolygon) {
                selectedPolygon = null;
                document.getElementById('menu-item-4').style.display = 'none';
            }
        });

        map.on('click', function(e) {
            var contextMenu = document.getElementById('custom-context-menu');

            if (contextMenu.style.display !== 'none') {
                contextMenu.style.display = 'none';
                return;
            }

            if (isDrawing) return;

            var clickedPoint = e.latlng;
            var clickedPointGeoJSON = turf.point([clickedPoint.lng, clickedPoint.lat]);
            var fixedAnObject = false;
            var reversedLayers = counties.getLayers().slice().reverse();

            reversedLayers.forEach(function(layer) {
                if (layer instanceof L.Polygon && !fixedAnObject) {
                    var polygonGeoJSON = layer.toGeoJSON();
                    var isInside = turf.booleanPointInPolygon(clickedPointGeoJSON, polygonGeoJSON);
                    if (isInside) {
                        fixedAnObject = true;
                        if (layer.customColor == 'yes') {
                            layer.setStyle({
                                fillOpacity: 0,
                                color: 'black',
                                weight: 2
                            });
                            layer.customColor = 'no';
                            layer.levelPreset = null;
                            layer.baseColor = null;
                            layer.animationState = null;
                        } else {
                            layer.customColor = 'yes';
                            layer.levelPreset = document.getElementById('levelPreset').value;
                            layer.baseColor = clickColor;
                            layer.baseWeight = 2;
                            layer.animationState = {
                                weightPulse: false
                            };
                            layer.setStyle({
                                fillOpacity: clickOpacity,
                                fillColor: layer.baseColor,
                                color: layer.baseColor,
                                weight: layer.baseWeight
                            });
                        }
                    }
                }
            });
        });

        var timeouter = null;
        document.getElementById("sizer").style.display = 'none';

        window.addEventListener('resize', function(event) {
            let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            let vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            document.getElementById("sizer").style.display = 'flex';
            document.getElementById("sizer").innerHTML = "<b>" + vw + "</b> x <b>" + vh + "</b>";
            clearTimeout(timeouter);
            timeouter = setTimeout(() => {
                document.getElementById("sizer").style.display = 'none';
            }, 1500);
        });

        const editableOverlay = document.getElementById('editableOverlay');
        const loader = document.getElementById('loader');
        const styleMenu = document.getElementById('style');
        const aboutMenu = document.getElementById('about');

        function updateOverlayVisibility() {
            if (loader.style.display !== 'none' || styleMenu.style.display !== 'none' || aboutMenu.style.display !== 'none') {
                editableOverlay.style.display = 'none';
            } else {
                editableOverlay.style.display = 'block';
            }
        }

        updateOverlayVisibility();

        const observer = new MutationObserver(updateOverlayVisibility);
        const observerConfig = {
            attributes: true,
            attributeFilter: ['style']
        };

        observer.observe(loader, observerConfig);
        observer.observe(styleMenu, observerConfig);
        observer.observe(aboutMenu, observerConfig);


        const DEFAULT_OPACITY = 0.3;

        document.getElementById('customColorPicker').style.display =
            document.getElementById('stylePreset').value === 'custom' ? 'flex' : 'none';

        function updateCurrentStyle() {
            const presetSelect = document.getElementById('stylePreset');
            if (presetSelect.value === 'custom') {
                clickColor = document.getElementById('styleColor').value;
            } else {
                clickColor = presetSelect.value;
            }
            clickOpacity = DEFAULT_OPACITY;
        }
        updateCurrentStyle();

        document.getElementById('stylePreset').addEventListener('change', function() {
            const customColorPicker = document.getElementById('customColorPicker');
            const colorPicker = document.getElementById('styleColor');

            if (this.value === 'custom') {
                customColorPicker.style.display = 'flex';
            } else {
                customColorPicker.style.display = 'none';
                colorPicker.value = this.value;
            }
            updateCurrentStyle();
        });

        document.getElementById('styleColor').addEventListener('input', function() {
            if (document.getElementById('stylePreset').value === 'custom') {
                updateCurrentStyle();
            }
        });

        let animationTick = 0;
        setInterval(function() {
            animationTick++;
            counties.eachLayer(function(layer) {
                if (layer instanceof L.Polygon && layer.customColor === 'yes' && layer.levelPreset && layer.animationState) {
                    const preset = layer.levelPreset;
                    const state = layer.animationState;
                    let newStyle = {};

                    const handleBorderPulse = (size, ticks) => {
                        if (animationTick % ticks === 0) {
                            state.weightPulse = !state.weightPulse;
                            newStyle.weight = state.weightPulse ? layer.baseWeight + size : layer.baseWeight;
                        }
                    };

                    switch (preset) {
                        case 'standard':
                            break;
                        case 'considerable':
                            handleBorderPulse(1, 2);
                            break;
                        case 'destructive':
                            handleBorderPulse(2, 2);
                            break;
                        case 'pds':
                            handleBorderPulse(4, 1);
                            break;
                        case 'emergency':
                            handleBorderPulse(8, 1);
                            break;
                    }

                    if (Object.keys(newStyle).length > 0) {
                        layer.setStyle(newStyle);
                    }
                }
            });
        }, 500);

        function preventEditableOverflow(event) {
            const element = event.target;

            while (element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth) {
                element.innerText = element.innerText.slice(0, -1);
            }

            const range = document.createRange();
            const selection = window.getSelection();

            if (element.childNodes.length > 0) {
                const lastChild = element.childNodes[element.childNodes.length - 1];
                const length = (lastChild.nodeValue || "").length;

                range.setStart(lastChild, length);
                range.collapse(true);

                selection.removeAllRanges();
                selection.addRange(range);
            }
        }

        const editableElements = document.querySelectorAll('#editableOverlay [contenteditable="true"]');
        editableElements.forEach(el => {
            el.addEventListener('input', preventEditableOverflow);
        });
    </script>
</body>

</html>
